{"version":3,"sources":["webpack://flipnote/webpack/universalModuleDefinition","webpack://flipnote/webpack/bootstrap","webpack://flipnote/./utils/dataStream.js","webpack://flipnote/./webgl/canvas.js","webpack://flipnote/./parser/index.js","webpack://flipnote/./parser/ppm.js","webpack://flipnote/./parser/kwz.js","webpack://flipnote/./flipnote.js","webpack://flipnote/./player/index.js","webpack://flipnote/./webgl/shader.vert","webpack://flipnote/./webgl/shader.frag","webpack://flipnote/./utils/adpcm.js","webpack://flipnote/./loader/index.js","webpack://flipnote/./loader/urlLoader.js","webpack://flipnote/./loader/fileLoader.js","webpack://flipnote/./loader/arrayBufferLoader.js","webpack://flipnote/./player/audio.js","webpack://flipnote/./encoders/wav.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","dataStream","arrayBuffer","_classCallCheck","buffer","_data","DataView","_offset","offset","whence","byteLength","val","getUint8","setUint8","getInt8","setInt8","littleEndian","arguments","length","undefined","getUint16","setUint16","getInt16","setInt16","getUint32","setUint32","getInt32","setInt32","count","reverse","bytes","Uint8Array","hex","push","toString","padStart","join","toUpperCase","chars","str","char","String","fromCharCode","string","charCodeAt","writeUint8","Uint16Array","webglCanvas","el","width","height","params","antialias","alpha","gl","getContext","program","createProgram","refs","shaders","textures","buffers","vShader","_createShader","VERTEX_SHADER","vertexShader","fShader","FRAGMENT_SHADER","fragmentShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","log","getProgramInfoLog","deleteProgram","Error","useProgram","vertBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","activeTexture","TEXTURE0","tex","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","uniforms","uniformCount","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","uniform1i","u_bitmap","setFilter","setMode","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","encoderOptions","toDataURL","filter","LINEAR","NEAREST","u_isSmooth","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","textureType","ALPHA","LUMINANCE_ALPHA","color","uniform4f","clearColor","color1","color2","depth","texImage2D","UNSIGNED_BYTE","setColor","drawArrays","TRIANGLES","viewport","clear","COLOR_BUFFER_BIT","forEach","texture","deleteTexture","deleteBuffer","canvas","magic","ppmParser","kwzParser","_adpcm","FRAMERATES","1","2","3","4","5","6","7","8","WIDTH","HEIGHT","BLACK","WHITE","BLUE","RED","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","seek","_frameDataLength","readUint32","_soundDataLength","frameCount","Math","min","readUint16","thumbFrameIndex","offsetTableLength","_frameOffsets","Uint32Array","map","_decodeSoundHeader","meta","_decodeMeta","_layers","_prevLayers","_prevFrameIndex","readHex","readUtf8","unpacked","byteOffset","byte","readUint8","bitOffset","lock","thumbIndex","readInt16","rootAuthorName","readUtf16","parentAuthorName","currentAuthorName","parentAuthorId","currentAuthorId","parentFilename","readFilename","currentFilename","rootAuthorId","timestamp","Date","loop","frame_count","frame_speed","frameSpeed","bgm_speed","bgmSpeed","thumb_index","spinoff","filename","username","fsid","parent","current","bgmLen","se1Len","se2Len","se3Len","framerate","bgmrate","soundMeta","bgm","se1","se2","se3","index","header","paperColor","pen","isNewFrame","decodeFrame","isTranslated","translateX","translateY","set","fill","readInt8","layerEncoding","readLineEncoding","layer","layerBitmap","line","chunkOffset","lineType","lineHeader","chunk","pixel","dest","src","y","x","trackIndex","id","track","decodeAdpcm","_this2","Array","test","PALETTE","_table1","_table2","_table3","values","a","b","_linetable","e","f","g","h","_bitIndex","_bitValue","load","sections","size","sectionCount","sectionMagic","substring","sectionLength","frameMeta","frameOffsets","frame","flags","layerSize","frameAuthor","layerDepth","soundFlags","cameraFlag","_prevDecodedFrame","num","nextBits","mask","result","creationTimestamp","modifiedTimestamp","rootFilename","creation_timestamp","frameIndex","diffingFlag","isPrevFrame","getDiffingFlag","layerIndex","skip","tileOffsetY","tileOffsetX","subTileOffsetY","subTileOffsetX","pixelOffset","pixelBuffer","readBits","lineIndex","pixels","subarray","lineValue","lineIndexA","lineIndexB","console","warn","pattern","layers","image","_","version","VERSION","player","parser","default","flipnotePlayer","document","querySelector","_imgCanvas","createElement","preserveDrawingBuffer","_isOpen","_events","currentFrame","paused","audioTracks","audioTrack","smoothRendering","note","fileLength","hasAudioTrack","decodeAudio","_audiorate","_seFlags","decodeSoundFlags","_playbackLoop","_hasPlaybackStarted","layerVisiblity","setFrame","emit","close","_loader2","then","_load","catch","err","error","pause","_frame","unset","destroy","active","start","currentTime","stop","_playBgm","setInterval","clearInterval","_stopAudio","firstFrame","_playFrameSe","nextFrame","setSize","max","drawFrame","toImage","floor","_playbackFrameTime","colors","getFramePalette","layerBuffers","setPaperColor","drawLayer","resize","forceUpdate","eventType","callback","events","callbackList","splice","indexOf","_len","args","_key","apply","duration","round","audio","volume","muted","inputBuffer","statePrevSample","statePrevIndex","outputBuffer","Int16Array","outputOffset","inputOffset","decodeSample","indexTable","stepSizeTable","sample","predSample","step","difference","clamp","Promise","resolve","reject","loaders","loader","matches","urlLoader","fileLoader","arrayBufferLoader","xhr","XMLHttpRequest","open","responseType","onreadystatechange","readyState","status","response","statusText","send","File","reader","FileReader","onload","event","target","onerror","readAsArrayBuffer","ArrayBuffer","channelCount","bitsPerSample","sampleRate","playbackRate","preload","pcmData","wav","wavEncoder","writeFrames","url","window","URL","createObjectURL","getBlob","revokeObjectURL","play","channels","headerBuffer","writeUtf8","writeUint32","writeUint16","Blob"],"mappings":"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","file":"flipnote.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flipnote\"] = factory();\n\telse\n\t\troot[\"flipnote\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/** datastream serves as a wrapper around the DataView API to help keep track of the offset into the stream */\nexport default class dataStream {\n  /**\n  * Create a fileReader instance\n  * @param {ArrayBuffer} arrayBuffer - data to read from\n  */\n  constructor(arrayBuffer) {\n    this.buffer = arrayBuffer;\n    this._data = new DataView(arrayBuffer);\n    this._offset = 0;\n  }\n\n  /**\n  * Get the length of the stream\n  * @returns {number}\n  */\n  get byteLength() {\n    return this._data.byteLength;\n  }\n\n  /**\n  * based on the seek method from Python's file objects - https://www.tutorialspoint.com/python/file_seek.htm\n  * @param {number} offset - position of the read pointer within the stream\n  * @param {number} whence - (optional) defaults to absolute file positioning,\n  *                          1 = offset is relative to the current position\n  *                          2 = offset is relative to the stream's end\n  */\n  seek(offset, whence) {\n    switch (whence) {\n      case 2:\n        this._offset = this._data.byteLength + offset;\n        break;\n      case 1:\n        this._offset += offset;\n        break;\n      case 0:\n      default:\n        this._offset = offset;\n        break;\n    }\n  }\n\n  /**\n  * Read an unsigned 8-bit integer from the stream, and automatically increment the offset\n  * @returns {number}\n  */\n  readUint8() {\n    var val = this._data.getUint8(this._offset);\n    this._offset += 1;\n    return val;\n  }\n\n  /**\n  * Write an unsigned 8-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  */\n  writeUint8(value) {\n    this._data.setUint8(this._offset, value);\n    this._offset += 1;\n  }\n\n  /**\n  * Read a signed 8-bit integer from the stream, and automatically increment the offset\n  * @returns {number}\n  */\n  readInt8() {\n    var val = this._data.getInt8(this._offset);\n    this._offset += 1;\n    return val;\n  }\n\n  /**\n  * Write a signed 8-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  */\n  writeInt8(value) {\n    this._data.setInt8(this._offset, value);\n    this._offset += 1;\n  }\n\n  /**\n  * Read an unsigned 16-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readUint16(littleEndian=true) {\n    var val = this._data.getUint16(this._offset, littleEndian);\n    this._offset += 2;\n    return val;\n  }\n\n  /**\n  * Write an unsigned 16-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeUint16(value, littleEndian=true) {\n    this._data.setUint16(this._offset, value, littleEndian);\n    this._offset += 2;\n  }\n\n  /**\n  * Read a signed 16-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readInt16(littleEndian=true) {\n    var val = this._data.getInt16(this._offset, littleEndian);\n    this._offset += 2;\n    return val;\n  }\n\n  /**\n  * Write a signed 16-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeInt16(value, littleEndian=true) {\n    this._data.setInt16(this._offset, value, littleEndian);\n    this._offset += 2;\n  }\n\n  /**\n  * Read an unsigned 32-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readUint32(littleEndian=true) {\n    var val = this._data.getUint32(this._offset, littleEndian);\n    this._offset += 4;\n    return val;\n  }\n\n  /**\n  * Write an unsigned 32-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeUint32(value, littleEndian=true) {\n    this._data.setUint32(this._offset, value, littleEndian);\n    this._offset += 4;\n  }\n\n  /**\n  * Read a signed 32-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readInt32(littleEndian=true) {\n    var val = this._data.getInt32(this._offset, littleEndian);\n    this._offset += 4;\n    return val;\n  }\n\n  /**\n  * Write a signed 32-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeInt32(value, littleEndian=true) {\n    this._data.setInt32(this._offset, value, littleEndian);\n    this._offset += 4;\n  }\n\n\n  /**\n  * Read bytes and return a hex string\n  * @param {number} count - number of bytes to read\n  * @param {bool} reverse - pass true to reverse byte order\n  * @returns {string}\n  */\n  readHex(count, reverse=false) {\n    var bytes = new Uint8Array(this._data.buffer, this._offset, count);\n    this._offset += bytes.byteLength;\n    let hex = [];\n    for (let i = 0; i < bytes.length; i++) {\n      hex.push(bytes[i].toString(16).padStart(2, \"0\"));\n    }\n    if (reverse) hex.reverse();\n    return hex.join(\"\").toUpperCase();\n  }\n\n  /**\n  * Read (simple) utf8 string\n  * @param {number} count - number of characters to read\n  * @returns {string}\n  */\n  readUtf8(count) {\n    var chars = new Uint8Array(this._data.buffer, this._offset, count);\n    this._offset += chars.byteLength;\n    var str = \"\";\n    for (let i = 0; i < chars.length; i++) {\n      let char = chars[i];\n      if (char == 0) break;\n      str += String.fromCharCode(char);\n    }\n    return str;\n  }\n\n  /**\n  * Write (simple) utf8 string\n  * @param {string} string - string to write\n  */\n  writeUtf8(string) {\n    for (let i = 0; i < string.length; i++) {\n      let char = string.charCodeAt(i);\n      this.writeUint8(char);\n    }\n  }\n\n  /**\n  * Read (simple) utf16 string\n  * @param {number} count - number of characters to read\n  * @returns {string}\n  */\n  readUtf16(count) {\n    var chars = new Uint16Array(this._data.buffer, this._offset, count);\n    this._offset += chars.byteLength;\n    var str = \"\";\n    for (let i = 0; i < chars.length; i++) {\n      let char = chars[i];\n      if (char == 0) break;\n      str += String.fromCharCode(char);\n    }\n    return str;\n  }\n}","import vertexShader from \"./shader.vert\";\nimport fragmentShader from \"./shader.frag\";\n\n/** webgl canvas wrapper class */\nexport default class webglCanvas {\n  /**\n  * Create a rendering canvas\n  * @param {HTMLCanvasElement} el - The HTML canvas element\n  * @param {number} width - width of the canvas in pixels\n  * @param {number} height - height of the canvas in pixels\n  * @param {Object} params - optional params to pass to web gl context\n  */\n  constructor(el, width=640, height=480, params={antialias: false, alpha: false}) {\n    this.width = el.width = width;\n    this.height = el.height = height; \n    var gl = el.getContext(\"webgl\", params);\n    var program = gl.createProgram();\n    this.program = program;\n    this.el = el;\n    this.gl = gl;\n    this.refs = {\n      shaders:[],\n      textures:[],\n      buffers: []\n    };\n    // set up shaders\n    var vShader = this._createShader(gl.VERTEX_SHADER, vertexShader);\n    var fShader = this._createShader(gl.FRAGMENT_SHADER, fragmentShader);\n    gl.attachShader(program, vShader);\n    gl.attachShader(program, fShader);\n    // link program\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      let log = gl.getProgramInfoLog(program);\n      gl.deleteProgram(program);\n      throw new Error(log);\n    }\n    // activate the program\n    gl.useProgram(program);\n    // create quad that fills the screen, this will be our drawing surface\n    var vertBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1,  1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(0);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    this.refs.buffers.push(vertBuffer);\n    // create texture to use as the layer bitmap\n    gl.activeTexture(gl.TEXTURE0);\n    var tex = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    // get uniform locations\n    this.uniforms = {};\n    let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < uniformCount; i++) {\n      let name = gl.getActiveUniform(program, i).name;\n      this.uniforms[name] = gl.getUniformLocation(program, name);\n    }\n    gl.uniform1i(this.uniforms.u_bitmap, 0);\n    this.setFilter(\"linear\");\n    this.setMode(\"PPM\");\n    this.refs.textures.push(tex);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n  }\n  \n  /**\n  * Util to compile and attach a new shader\n  * @param {shader type} type - gl.VERTEX_SHADER | gl.FRAGMENT_SHADER\n  * @param {string} source - GLSL code for the shader\n  * @returns {shader} compiled webgl shader\n  * @access protected \n  */\n  _createShader(type, source) {\n    var gl = this.gl;\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    // test if shader compilation was successful\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      let log = gl.getShaderInfoLog(shader);\n      gl.deleteShader(shader);\n      throw new Error(log);\n    }\n    this.refs.shaders.push(shader);\n    return shader;\n  }\n\n  /**\n  * get the canvas content as an image\n  * @param {string} type - image MIME type, default is image/png\n  * @param {number} encoderOptions - number between 0 and 1 indicating image quality if type is image/jpeg or image/webp\n  * @returns {DataUrl}\n  */\n  toImage(type, encoderOptions) {\n    return this.el.toDataURL(type, encoderOptions);\n  }\n\n  /**\n  * Set the texture filter\n  * @param {string} filter - \"linear\" | \"nearest\"\n  */\n  setFilter(filter) {\n    var gl = this.gl;\n    filter = filter == \"linear\" ? gl.LINEAR : gl.NEAREST;\n    gl.uniform1i(this.uniforms.u_isSmooth, filter == \"linear\" ? 0 : 1);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n  }\n\n  /**\n  * Set the canvas mode depending on format\n  * @param {string} mode - \"KWZ\" | \"PPM\"\n  */\n  setMode(mode) {\n    const { gl } = this;\n    if (mode === \"PPM\") {\n      this.textureType = gl.ALPHA;\n    } else if (mode === \"KWZ\") {\n      this.textureType = gl.LUMINANCE_ALPHA;\n    }\n  }\n\n  /**\n  * Set a color\n  * @param {string} color - name of the color's uniform variable\n  * @param {array} value - r,g,b color, each channel's value should be between 0 and 255\n  */\n  setColor(color, value) {\n    this.gl.uniform4f(this.uniforms[color], value[0]/255, value[1]/255, value[2]/255, 1);\n  }\n\n  /**\n  * Set an palette individual color\n  * @param {array} value - r,g,b color, each channel's value should be between 0 and 255\n  */\n  setPaperColor(value) {\n    this.gl.clearColor(value[0] / 255, value[1] / 255, value[2] / 255, 1);\n  }\n\n  /**\n  * Draw a single frame layer\n  * @param {Uint16Array} buffer - layer pixels\n  * @param {number} width - layer width\n  * @param {number} height - layer height\n  * @param {array} color1 - r,g,b for layer color 1, each channel's value should be between 0 and 255\n  * @param {array} color2 - r,g,b for layer color 2, each channel's value should be between 0 and 255\n  * @param {number} depth - layer depth (kwz only, but currently unused)\n  */\n  drawLayer(buffer, width, height, color1, color2, depth) {\n    let gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0);\n    gl.texImage2D(gl.TEXTURE_2D, 0, this.textureType, width, height, 0, this.textureType, gl.UNSIGNED_BYTE, buffer);\n    // gl.uniform1f(gl.getUniformLocation(this.program, \"u_layerDepth\"), -depth/6);\n    this.setColor(\"u_color1\", color1);\n    this.setColor(\"u_color2\", color2);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  /**\n  * Resize canvas\n  * @param {number} width - width of the canvas in pixels\n  * @param {number} height - height of the canvas in pixels\n  */\n  resize(width=640, height=480) {\n    this.el.width = width;\n    this.el.height = height; \n    this.width = width;\n    this.height = height;\n    this.gl.viewport(0, 0, width, height);\n  }\n\n  /**\n  * Clear canvas\n  */\n  clear() {\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n  }\n\n  /** \n  * Destroy this canvas instance\n  */\n  destroy() {\n    // free resources\n    var refs = this.refs;\n    var gl = this.gl;\n    refs.shaders.forEach((shader) => {\n      gl.deleteShader(shader);\n    });\n    refs.shaders = [];\n    refs.textures.forEach((texture) => {\n      gl.deleteTexture(texture);\n    });\n    refs.textures = [];\n    refs.buffers.forEach((buffer) => {\n      gl.deleteBuffer(buffer);\n    });\n    refs.buffers = [];\n    gl.deleteProgram(this.program);\n    // shrink the canvas to reduce memory usage until it is garbage collected\n    gl.canvas.width = 1;\n    gl.canvas.height = 1;\n  }\n}","import ppmParser from \"./ppm\";\nimport kwzParser from \"./kwz\";\n\nexport default function parser(arrayBuffer) {\n  // check the buffer's magic to identify which format it uses\n  let data = new DataView(arrayBuffer, 0, 4);\n  let magic = data.getUint32(0);\n  // check if magic is PARA (ppm magic)\n  if (magic == 0x50415241) {\n    return new ppmParser(arrayBuffer);\n  } \n  // check if magic is KFH (kwz magic)\n  else if ((magic & 0xFFFFFF00) == 0x4B464800) {\n    return new kwzParser(arrayBuffer);\n  }\n}","/**\n * PPM decoder\n * Reads frames, audio, and metadata from Flipnote Studio PPM files \n * Based on my Python PPM decoder implementation (https://github.com/jaames/flipnote-tools)\n *  \n * Credits:\n *  PPM format reverse-engineering and documentation:\n *   - bricklife (http://ugomemo.g.hatena.ne.jp/bricklife/20090307/1236391313)\n *   - mirai-iro (http://mirai-iro.hatenablog.jp/entry/20090116/ugomemo_ppm)\n *   - harimau_tigris (http://ugomemo.g.hatena.ne.jp/harimau_tigris)\n *   - steven (http://www.dsibrew.org/wiki/User:Steven)\n *   - yellows8 (http://www.dsibrew.org/wiki/User:Yellows8)\n *   - PBSDS (https://github.com/pbsds)\n *   - jaames (https://github.com/jaames)\n *  Identifying the PPM sound codec:\n *   - Midmad from Hatena Haiku\n *   - WDLMaster from hcs64.com\n *  Helping me to identify issues with the Python decoder that this is based on:\n *   - Austin Burk (https://sudomemo.net)\n * \n *  Lastly, a huge thanks goes to Nintendo for creating Flipnote Studio, \n *  and to Hatena for providing the Flipnote Hatena online service, both of which inspired so many c:\n*/\n\nimport dataStream from \"utils/dataStream\";\nimport {decodeAdpcm} from \"utils/adpcm\";\n\n// internal framerate value -> FPS table\nconst FRAMERATES = {\n  1: 0.5,\n  2: 1,\n  3: 2,\n  4: 4,\n  5: 6,\n  6: 12,\n  7: 20,\n  8: 30,\n};\n\nconst WIDTH = 256;\nconst HEIGHT = 192;\nconst BLACK = [0x0E, 0x0E, 0x0E];\nconst WHITE = [0xFF, 0xFF, 0xff];\nconst BLUE = [0x0A, 0x39, 0xFF];\nconst RED = [0xFF, 0x2A, 0x2A];\n\nexport default class ppmParser extends dataStream {\n  /**\n  * Create a ppmDecoder instance\n  * @param {ArrayBuffer} arrayBuffer - data to read from\n  */\n  constructor(arrayBuffer) {\n    super(arrayBuffer);\n    this.type = \"PPM\";\n    this.seek(4);\n    // decode header\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#file-header\n    this._frameDataLength = this.readUint32();\n    this._soundDataLength = this.readUint32();\n    this.frameCount = Math.min(this.readUint16() + 1, 999);\n    this.seek(18);\n    this.thumbFrameIndex = this.readUint16();\n    // jump to the start of the animation data section\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#animation-data-section\n    this.seek(0x06A0);\n    var offsetTableLength = this.readUint16();\n    // skip padding + flags\n    this.seek(0x06A8);\n    // read frame offsets and build them into a table\n    this._frameOffsets = new Uint32Array(offsetTableLength / 4).map(value => {\n      return 0x06A8 + offsetTableLength + this.readUint32();\n    });\n    this._decodeSoundHeader();\n    this.meta = this._decodeMeta();\n    // create image buffers\n     this._layers = [\n      new Uint8Array(WIDTH * HEIGHT),\n      new Uint8Array(WIDTH * HEIGHT)\n    ];\n    this._prevLayers = [\n      new Uint8Array(WIDTH * HEIGHT),\n      new Uint8Array(WIDTH * HEIGHT)\n    ];\n    this._prevFrameIndex = 0;\n  }\n\n  static validateFSID(fsid) {\n    return /[0159]{1}[0-9A-F]{6}0[0-9A-F]{8}/.test(fsid);\n  }\n\n  static validateFilename(filename) {\n    return /[0-9A-F]{6}_[0-9A-F]{13}_[0-9]{3}/.test(filename);\n  }\n\n  /**\n  * Read a packed filename\n  * @returns {string}\n  * @access protected\n  */\n  readFilename() {\n    return [\n      this.readHex(3),\n      this.readUtf8(13),\n      this.readUint16().toString().padStart(3, \"0\")\n    ].join(\"_\");\n  }\n\n  /**\n  * Unpack the line encoding flags for all 192 lines in a layer\n  * @returns {array}\n  * @access protected\n  */\n  readLineEncoding() {\n    var unpacked = new Uint8Array(HEIGHT);\n    for (var byteOffset = 0; byteOffset < 48; byteOffset ++) {\n      var byte = this.readUint8();\n      // each line's encoding type is stored as a 2-bit value\n      for (var bitOffset = 0; bitOffset < 8; bitOffset += 2) {\n        unpacked[byteOffset * 4 + bitOffset / 2] = (byte >> bitOffset) & 0x03;\n      }\n    }\n    return unpacked;\n  }\n\n  /**\n  * Decode the main PPM metadata, like username, timestamp, etc\n  * @returns {object}\n  * @access protected\n  */\n  _decodeMeta() {\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#file-header\n    this.seek(0x10);\n    var lock = this.readUint16(),\n        thumbIndex = this.readInt16(),\n        rootAuthorName = this.readUtf16(11),\n        parentAuthorName = this.readUtf16(11),\n        currentAuthorName = this.readUtf16(11),\n        parentAuthorId = this.readHex(8, true),\n        currentAuthorId = this.readHex(8, true),\n        parentFilename = this.readFilename(),\n        currentFilename = this.readFilename(),\n        rootAuthorId = this.readHex(8, true);\n    this.seek(0x9A);\n    var timestamp = new Date((this.readUint32() + 946684800) * 1000);\n    this.seek(0x06A6);\n    var flags = this.readUint16();\n    return {\n      lock: lock,\n      loop: flags >> 1 & 0x01,\n      frame_count: this.frameCount,\n      frame_speed: this.frameSpeed,\n      bgm_speed: this.bgmSpeed,\n      thumb_index: thumbIndex,\n      timestamp: timestamp,\n      spinoff: (currentAuthorId !== parentAuthorId) || (currentAuthorId !== rootAuthorId),\n      root: {\n        filename: null,\n        username: rootAuthorName,\n        fsid: rootAuthorId,\n      },\n      parent: {\n        username: parentAuthorName,\n        fsid: parentAuthorId,\n        filename: parentFilename\n      },\n      current: {\n        username: currentAuthorName,\n        fsid: currentAuthorId,\n        filename: currentFilename\n      },\n    };\n  }\n\n  /**\n  * Decode the sound header to get audio track lengths and frame/bgm sppeds\n  * @access protected\n  */\n  _decodeSoundHeader() {\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#sound-data-section\n    // offset = frame data offset + frame data length + sound effect flags\n    var offset = 0x06A0 + this._frameDataLength + this.frameCount;\n    // account for multiple-of-4 padding\n    if (offset % 4 != 0) offset += 4 - (offset % 4);\n    this.seek(offset);\n    var bgmLen = this.readUint32();\n    var se1Len = this.readUint32();\n    var se2Len = this.readUint32();\n    var se3Len = this.readUint32();\n    this.frameSpeed = 8 - this.readUint8();\n    this.bgmSpeed = 8 - this.readUint8();\n    offset += 32;\n    this.framerate = FRAMERATES[this.frameSpeed];\n    this.bgmrate = FRAMERATES[this.bgmSpeed];\n    this.soundMeta = {\n      \"bgm\": {offset: offset,           length: bgmLen},\n      \"se1\": {offset: offset += bgmLen, length: se1Len},\n      \"se2\": {offset: offset += se1Len, length: se2Len},\n      \"se3\": {offset: offset += se2Len, length: se3Len},\n    };\n  }\n\n  /**\n  * Check whether or not a given frame is based on the previous one\n  * @param {number} index - zero-based frame index \n  * @returns {boolean}\n  */\n  isNewFrame(index) {\n    this.seek(this._frameOffsets[index]);\n    var header = this.readUint8();\n    return (header >> 7) & 0x1;\n  }\n\n  /**\n  * Get the color palette for a given frame\n  * @param {number} index - zero-based frame index \n  * @returns {array} rgba palette in order of paper, layer1, layer2\n  */\n  getFramePalette(index) {\n    this.seek(this._frameOffsets[index]);\n    var header = this.readUint8();\n    var paperColor = header & 0x1;\n    var pen = [\n      null,\n      paperColor == 1 ? BLACK : WHITE,\n      RED,\n      BLUE,\n    ];\n    return [\n      paperColor == 1 ? WHITE : BLACK,\n      pen[(header >> 1) & 0x3], // layer 1 color\n      pen[(header >> 3) & 0x3], // layer 2 color\n    ];\n  }\n\n  /**\n  * Decode a frame\n  * @param {number} index - zero-based frame index \n  * @returns {array} - 2 uint8 arrays representing each layer\n  * */\n  decodeFrame(index) {\n    if ((index !== 0) && (this._prevFrameIndex !== index - 1) && (!this.isNewFrame(index)))\n      this.decodeFrame(index - 1);\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#animation-frame\n    this.seek(this._frameOffsets[index]);\n    var header = this.readUint8();\n    var isNewFrame = (header >> 7) & 0x1;\n    var isTranslated = (header >> 5) & 0x3;\n    var translateX = 0;\n    var translateY = 0;\n    // copy the current layer buffers to the previous ones\n    this._prevLayers[0].set(this._layers[0]);\n    this._prevLayers[1].set(this._layers[1]);\n    this._prevFrameIndex = index;\n    // reset current layer buffers\n    this._layers[0].fill(0);\n    this._layers[1].fill(0);\n\n    if (isTranslated) {\n      translateX = this.readInt8();\n      translateY = this.readInt8();\n    }\n\n    var layerEncoding = [\n      this.readLineEncoding(),\n      this.readLineEncoding()\n    ];\n     // start decoding layer bitmaps\n    for (var layer = 0; layer < 2; layer++) {\n      var layerBitmap = this._layers[layer];\n      for (var line = 0; line < HEIGHT; line++) {\n        var chunkOffset = line * WIDTH;\n        var lineType = layerEncoding[layer][line];\n        switch(lineType) {\n          // line type 0 = blank line, decode nothing\n          case 0:\n            break;\n          // line types 1 + 2 = compressed bitmap line\n          case 1:\n          case 2:\n            var lineHeader = this.readUint32(false);\n            // line type 2 starts as an inverted line\n            if (lineType == 2) layerBitmap.fill(0xFF, chunkOffset, chunkOffset + WIDTH);\n            // loop through each bit in the line header\n            while (lineHeader & 0xFFFFFFFF) {\n              // if the bit is set, this 8-pix wide chunk is stored\n              // else we can just leave it blank and move on to the next chunk\n              if (lineHeader & 0x80000000) {\n                var chunk = this.readUint8();\n                // unpack chunk bits\n                for (var pixel = 0; pixel < 8; pixel++) {\n                  layerBitmap[chunkOffset + pixel] = (chunk >> pixel & 0x1) ? 0xFF : 0x00;\n                }\n              }\n              chunkOffset += 8;\n              // shift lineheader to the left by 1 bit, now on the next loop cycle the next bit will be checked\n              lineHeader <<= 1;\n            }\n            break;\n          // line type 3 = raw bitmap line\n          case 3:\n            while(chunkOffset < (line + 1) * WIDTH) {\n              var chunk = this.readUint8();\n              for (var pixel = 0; pixel < 8; pixel++) {\n                layerBitmap[chunkOffset + pixel] = (chunk >> pixel & 0x1) ? 0xFF : 0x00\n              }\n              chunkOffset += 8;\n            }\n            break;\n        }\n      }\n    }\n    // if the current frame is based on changes from the preivous one, merge them by XORing their values\n    if (!isNewFrame) {\n      var dest, src;\n      for (var y = 0; y < HEIGHT; y++) {\n        for (var x = 0; x < WIDTH; x++) {\n          dest = x + y * WIDTH;\n          src = dest - (translateX + translateY * WIDTH);\n          if (!((x - translateX > WIDTH) || (x - translateX < 0))) {\n            this._layers[0][dest] ^= this._prevLayers[0][src];\n            this._layers[1][dest] ^= this._prevLayers[1][src];\n          }\n        }\n      }\n    }\n    return this._layers;\n  }\n\n  hasAudioTrack(trackIndex) {\n    let id = [\"bgm\", \"se1\", \"se2\", \"se3\"][trackIndex];\n    return this.soundMeta[id].length > 0;\n  }\n\n  /**\n  * Decode an audio track to 32-bit adpcm\n  * @param {string} track - track name, \"bgm\" | \"se1\" | \"se2\" | \"se3\"\n  * @returns {Int16Array}\n  */\n  decodeAudio(track) {\n    let meta = this.soundMeta[track];\n    let buffer = new Uint8Array(this.buffer, meta.offset, meta.length);\n    return decodeAdpcm(buffer);\n  }\n\n  /**\n  * Decode the sound effect usage for each frame\n  * @returns {array}\n  */\n  decodeSoundFlags() {\n    this.seek(0x06A0 + this._frameDataLength);\n    // per msdn docs - the array map callback is only invoked for array indicies that have assigned values\n    // so when we create an array, we need to fill it with something before we can map over it\n    var arr = new Array(this.frameCount).fill([]);\n    return arr.map(value => {\n      var byte = this.readUint8();\n      return [byte & 0x1, (byte >> 1) & 0x1, (byte >> 2) & 0x1];\n    });\n  }\n}","import dataStream from \"utils/dataStream\";\n\nconst FRAMERATES = [\n  0.2,\n  0.5,\n  1,\n  2,\n  4, \n  6,\n  8,\n  12, \n  20,\n  24,\n  30\n];\n\nconst PALETTE = [\n  [0xff, 0xff, 0xff],\n  [0x10, 0x10, 0x10],\n  [0xff, 0x10, 0x10],\n  [0xff, 0xe7, 0x00],\n  [0x00, 0x86, 0x31],\n  [0x00, 0x38, 0xce],\n  [0xff, 0xff, 0xff]\n];\n\nexport default class kwzParser extends dataStream {\n\n  constructor(arrayBuffer) {\n    super(arrayBuffer);\n    this.type = \"KWZ\";\n    // table1 - commonly occuring line offsets\n    this._table1 = new Uint16Array([\n      0x0000, 0x0CD0, 0x19A0, 0x02D9, 0x088B, 0x0051, 0x00F3, 0x0009,\n      0x001B, 0x0001, 0x0003, 0x05B2, 0x1116, 0x00A2, 0x01E6, 0x0012,\n      0x0036, 0x0002, 0x0006, 0x0B64, 0x08DC, 0x0144, 0x00FC, 0x0024,\n      0x001C, 0x0004, 0x0334, 0x099C, 0x0668, 0x1338, 0x1004, 0x166C\n    ]);\n    // table2 - commonly occuring line offsets, but the lines are shifted to the left by one pixel\n    this._table2 = new Uint16Array([\n      0x0000, 0x0CD0, 0x19A0, 0x0003, 0x02D9, 0x088B, 0x0051, 0x00F3, \n      0x0009, 0x001B, 0x0001, 0x0006, 0x05B2, 0x1116, 0x00A2, 0x01E6, \n      0x0012, 0x0036, 0x0002, 0x02DC, 0x0B64, 0x08DC, 0x0144, 0x00FC, \n      0x0024, 0x001C, 0x099C, 0x0334, 0x1338, 0x0668, 0x166C, 0x1004\n    ]);\n    // table3 - line offsets, but the lines are shifted to the left by one pixel\n    this._table3 = new Uint16Array(6561);\n    var values = [0, 3, 7, 1, 4, 8, 2, 5, 6];\n    let index = 0;\n    for (let a = 0; a < 9; a++)\n      for (let b = 0; b < 9; b++)\n        for (let c = 0; c < 9; c++)\n          for (let d = 0; d < 9; d++) {\n            this._table3[index] = ((values[a] * 9 + values[b]) * 9 + values[c]) * 9 + values[d];\n            index++;\n          }\n    // linetable - contains every possible sequence of pixels for each tile line\n    this._linetable = new Uint16Array(6561 * 8);\n    var values = [0x0000, 0xFF00, 0x00FF];\n    let offset = 0;\n    for (let a = 0; a < 3; a++)\n      for (let b = 0; b < 3; b++)\n        for (let c = 0; c < 3; c++)\n          for (let d = 0; d < 3; d++)\n            for (let e = 0; e < 3; e++)\n              for (let f = 0; f < 3; f++)\n                for (let g = 0; g < 3; g++)\n                  for (let h = 0; h < 3; h++) {\n                    this._linetable.set([\n                      values[b], \n                      values[a], \n                      values[d], \n                      values[c], \n                      values[f], \n                      values[e], \n                      values[h], \n                      values[g]\n                    ], offset);\n                    offset += 8;\n                  }\n\n    // convert to uint8 array\n    // this._linetable = new Uint8Array(this._linetable.buffer);\n\n    this._layers = [\n      new Uint16Array(320 * 240),\n      new Uint16Array(320 * 240),\n      new Uint16Array(320 * 240),\n    ];\n    this._bitIndex = 0;\n    this._bitValue = 0;\n    this.load();\n  }\n\n  load() {\n    this.seek(0);\n    this.sections = {};\n    let size = this.byteLength - 256;\n    let offset = 0;\n    let sectionCount = 0;\n    // counting sections should mitigate against one of mrnbayoh's notehax exploits\n    while ((offset < size) && (sectionCount < 6)) {\n      this.seek(offset);\n      let sectionMagic = this.readUtf8(4).substring(0, 3);\n      let sectionLength = this.readUint32();\n      this.sections[sectionMagic] = {\n        offset: offset,\n        length: sectionLength\n      };\n      offset += sectionLength + 8;\n      sectionCount += 1;\n    }\n\n    this.meta = this._decodeMeta();\n\n    this.frameMeta = [];\n    this.frameOffsets = [];\n    this.seek(this.sections[\"KMI\"].offset + 8);\n    offset = this.sections[\"KMC\"].offset + 12;\n    for (let i = 0; i < this.frameCount; i++) {\n      let frame = {\n        flags: this.readUint32(),\n        layerSize: [\n          this.readUint16(),\n          this.readUint16(),\n          this.readUint16()\n        ],\n        frameAuthor: this.readUtf8(10),\n        layerDepth: [\n          this.readUint8(),\n          this.readUint8(),\n          this.readUint8(),\n        ],\n        soundFlags: this.readUint8(),\n        cameraFlag: this.readUint32(),\n      };\n      this.frameMeta.push(frame);\n      this.frameOffsets.push(offset);\n      offset += frame.layerSize[0] + frame.layerSize[1] + frame.layerSize[2];\n    }\n    this._prevDecodedFrame = -1;\n  }\n\n  readBits(num) {\n    if (this._bitIndex + num > 16) {\n      let nextBits = this.readUint16();\n      this._bitValue |= nextBits << (16 - this._bitIndex);\n      this._bitIndex -= 16;\n    }\n    let mask = (1 << num) - 1;\n    let result = this._bitValue & mask;\n    this._bitValue >>= num;\n    this._bitIndex += num;\n    return result;\n  }\n\n  _decodeMeta() {\n    this.seek(this.sections[\"KFH\"].offset + 12);\n    let creationTimestamp = new Date((this.readUint32() + 946684800) * 1000),\n        modifiedTimestamp = new Date((this.readUint32() + 946684800) * 1000),\n        appVersion = this.readUint32(),\n        rootAuthorId = this.readHex(10),\n        parentAuthorId = this.readHex(10),\n        currentAuthorId = this.readHex(10),\n        rootAuthorName = this.readUtf16(11),\n        parentAuthorName = this.readUtf16(11),\n        currentAuthorName = this.readUtf16(11),\n        rootFilename = this.readUtf8(28),\n        parentFilename = this.readUtf8(28),\n        currentFilename = this.readUtf8(28),\n        frameCount = this.readUint16(),\n        thumbIndex = this.readUint16(),\n        flags = this.readUint16(),\n        frameSpeed = this.readUint8(),\n        layerFlags = this.readUint8();\n    this.frameCount = frameCount;\n    this.thumbFrameIndex = thumbIndex;\n    this.frameSpeed = frameSpeed;\n    this.framerate = FRAMERATES[frameSpeed];\n    return {\n      lock: flags & 0x1,\n      loop: (flags >> 1) & 0x01,\n      frame_count: frameCount,\n      frame_speed: frameSpeed,\n      thumb_index: thumbIndex,\n      timestamp: modifiedTimestamp,\n      creation_timestamp: creationTimestamp,\n      root: {\n        username: rootAuthorName,\n        fsid: rootAuthorId,\n        filename: rootFilename,\n      },\n      parent: {\n        username: parentAuthorName,\n        fsid: parentAuthorId,\n        filename: parentFilename,\n      },\n      current: {\n        username: currentAuthorName,\n        fsid: currentAuthorId,\n        filename: currentFilename,\n      },\n    };\n  }\n\n  getDiffingFlag(frameIndex) {\n    return ~(this.frameMeta[frameIndex].flags >> 4) & 0x07;\n  }\n\n  getLayerDepths(frameIndex) {\n    return this.frameMeta[frameIndex].layerDepth;\n  }\n\n  decodeFrame(frameIndex, diffingFlag=0x7, isPrevFrame=false) {\n    // if this frame is being decoded as a prev frame, then we only want to decode the layers necessary\n    if (isPrevFrame)\n      diffingFlag &= this.getDiffingFlag(frameIndex + 1);\n    // the prevDecodedFrame check is an optimisation for decoding frames in full sequence\n    if ((frameIndex !== 0) && (this._prevDecodedFrame !== frameIndex - 1) && (diffingFlag))\n      this.decodeFrame(frameIndex - 1, diffingFlag=diffingFlag, isPrevFrame=true);\n\n    let meta = this.frameMeta[frameIndex];\n    let offset = this.frameOffsets[frameIndex];\n\n    for (let layerIndex = 0; layerIndex < 3; layerIndex++) {\n      this.seek(offset);\n      let layerSize = meta.layerSize[layerIndex];\n      offset += layerSize;\n\n      // if the layer is 38 bytes then it hasn't changed at all since the previous frame, so we can skip it\n      if (layerSize === 38) continue;\n\n      if ((diffingFlag >> layerIndex) & 0x1 === 0) continue;\n\n      this._bitIndex = 16;\n      this._bitValue = 0;\n      let skip = 0;\n\n      for (let tileOffsetY = 0; tileOffsetY < 240; tileOffsetY += 128) {\n        for (let tileOffsetX = 0; tileOffsetX < 320; tileOffsetX += 128) {\n          for (let subTileOffsetY = 0; subTileOffsetY < 128; subTileOffsetY += 8) {\n            let y = tileOffsetY + subTileOffsetY;\n            if (y >= 240) break;\n\n            for (let subTileOffsetX = 0; subTileOffsetX < 128; subTileOffsetX += 8) {\n              let x = tileOffsetX + subTileOffsetX;\n              if (x >= 320) break;\n\n              if (skip) {\n                skip -= 1;\n                continue;\n              }\n\n              let pixelOffset = y * 320 + x;\n              let pixelBuffer = this._layers[layerIndex];\n\n              let type = this.readBits(3);\n\n              if (type == 0) {\n                let lineIndex = this._table1[this.readBits(5)];\n                let pixels = this._linetable.subarray(lineIndex * 8, lineIndex * 8 + 8);\n                pixelBuffer.set(pixels, pixelOffset);\n                pixelBuffer.set(pixels, pixelOffset + 320);\n                pixelBuffer.set(pixels, pixelOffset + 640);\n                pixelBuffer.set(pixels, pixelOffset + 960);\n                pixelBuffer.set(pixels, pixelOffset + 1280);\n                pixelBuffer.set(pixels, pixelOffset + 1600);\n                pixelBuffer.set(pixels, pixelOffset + 1920);\n                pixelBuffer.set(pixels, pixelOffset + 2240);\n              } \n\n              else if (type == 1) {\n                let lineIndex = this.readBits(13);\n                let pixels = this._linetable.subarray(lineIndex * 8, lineIndex * 8 + 8);\n                pixelBuffer.set(pixels, pixelOffset);\n                pixelBuffer.set(pixels, pixelOffset + 320);\n                pixelBuffer.set(pixels, pixelOffset + 640);\n                pixelBuffer.set(pixels, pixelOffset + 960);\n                pixelBuffer.set(pixels, pixelOffset + 1280);\n                pixelBuffer.set(pixels, pixelOffset + 1600);\n                pixelBuffer.set(pixels, pixelOffset + 1920);\n                pixelBuffer.set(pixels, pixelOffset + 2240);\n              } \n              \n              else if (type == 2) {\n                let lineValue = this.readBits(5);\n                let lineIndexA = this._table1[lineValue];\n                let lineIndexB = this._table2[lineValue];\n                let a = this._linetable.subarray(lineIndexA * 8, lineIndexA * 8 + 8);\n                let b = this._linetable.subarray(lineIndexB * 8, lineIndexB * 8 + 8);\n                pixelBuffer.set(a, pixelOffset);\n                pixelBuffer.set(b, pixelOffset + 320);\n                pixelBuffer.set(a, pixelOffset + 640);\n                pixelBuffer.set(b, pixelOffset + 960);\n                pixelBuffer.set(a, pixelOffset + 1280);\n                pixelBuffer.set(b, pixelOffset + 1600);\n                pixelBuffer.set(a, pixelOffset + 1920);\n                pixelBuffer.set(b, pixelOffset + 2240);\n              } \n              \n              else if (type == 3) {\n                let lineIndexA = this.readBits(13);\n                let lineIndexB = this._table3[lineIndexA];\n                let a = this._linetable.subarray(lineIndexA * 8, lineIndexA * 8 + 8);\n                let b = this._linetable.subarray(lineIndexB * 8, lineIndexB * 8 + 8);\n                pixelBuffer.set(a, pixelOffset);\n                pixelBuffer.set(b, pixelOffset + 320);\n                pixelBuffer.set(a, pixelOffset + 640);\n                pixelBuffer.set(b, pixelOffset + 960);\n                pixelBuffer.set(a, pixelOffset + 1280);\n                pixelBuffer.set(b, pixelOffset + 1600);\n                pixelBuffer.set(a, pixelOffset + 1920);\n                pixelBuffer.set(b, pixelOffset + 2240);\n              }\n\n              else if (type == 4) {\n                let mask = this.readBits(8);\n                for (let line = 0; line < 8; line++) {\n                  let lineIndex = 0;\n                  if (mask & (1 << line)) {\n                    lineIndex = this._table1[this.readBits(5)];\n                  } else {\n                    lineIndex = this.readBits(13);\n                  }\n                  let pixels = this._linetable.subarray(lineIndex * 8, lineIndex * 8 + 8);\n                  pixelBuffer.set(pixels, pixelOffset + line * 320);\n                }\n              }\n\n              else if (type == 5) {\n                skip = this.readBits(5);\n                continue;\n              }\n\n              else if (type == 6) {\n                console.warn(\"type 6??? nah m8\")\n              }\n\n              else if (type == 7) {\n                let pattern = this.readBits(2);\n                let useTable = this.readBits(1);\n                let lineIndexA = 0;\n                let lineIndexB = 0;\n\n                if (useTable) {\n                  lineIndexA = this._table1[this.readBits(5)];\n                  lineIndexB = this._table1[this.readBits(5)];\n                  pattern = (pattern + 1) % 4;\n                } else {\n                  lineIndexA = this.readBits(13);\n                  lineIndexB = this.readBits(13);\n                }\n\n                let a = this._linetable.subarray(lineIndexA * 8, lineIndexA * 8 + 8);\n                let b = this._linetable.subarray(lineIndexB * 8, lineIndexB * 8 + 8);\n\n                if (pattern == 0) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(b, pixelOffset + 320);\n                  pixelBuffer.set(a, pixelOffset + 640);\n                  pixelBuffer.set(b, pixelOffset + 960);\n                  pixelBuffer.set(a, pixelOffset + 1280);\n                  pixelBuffer.set(b, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(b, pixelOffset + 2240);\n                } else if (pattern == 1) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(a, pixelOffset + 320);\n                  pixelBuffer.set(b, pixelOffset + 640);\n                  pixelBuffer.set(a, pixelOffset + 960);\n                  pixelBuffer.set(a, pixelOffset + 1280);\n                  pixelBuffer.set(b, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(a, pixelOffset + 2240);\n                } else if (pattern == 2) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(b, pixelOffset + 320);\n                  pixelBuffer.set(a, pixelOffset + 640);\n                  pixelBuffer.set(a, pixelOffset + 960);\n                  pixelBuffer.set(b, pixelOffset + 1280);\n                  pixelBuffer.set(a, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(b, pixelOffset + 2240);\n                } else if (pattern == 3) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(b, pixelOffset + 320);\n                  pixelBuffer.set(b, pixelOffset + 640);\n                  pixelBuffer.set(a, pixelOffset + 960);\n                  pixelBuffer.set(b, pixelOffset + 1280);\n                  pixelBuffer.set(b, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(b, pixelOffset + 2240);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this._prevDecodedFrame = frameIndex;\n    // return this._layers;\n    return [\n      new Uint8Array(this._layers[0].buffer),\n      new Uint8Array(this._layers[1].buffer),\n      new Uint8Array(this._layers[2].buffer),\n    ];\n  }\n\n  getFramePalette(frameIndex) {\n    let flags = this.frameMeta[frameIndex].flags;\n    return [\n      PALETTE[flags & 0xF], // paper color\n      PALETTE[(flags >> 8) & 0xF], // layer A color 1\n      PALETTE[(flags >> 12) & 0xF], // layer A color 2\n      PALETTE[(flags >> 16) & 0xF], // layer B color 1\n      PALETTE[(flags >> 20) & 0xF], // layer B color 2\n      PALETTE[(flags >> 24) & 0xF], // layer C color 1\n      PALETTE[(flags >> 28) & 0xF], // layer C color 2\n    ];\n  }\n\n  getFrameImage(frameIndex) {\n    let layers = this.decodeFrame(frameIndex);\n    let image = new Uint8Array((320 * 240));\n    for (let pixel = 0; pixel < (320 * 240); pixel++) {\n      let a = layers[0][pixel];\n      let b = layers[1][pixel];\n      let c = layers[2][pixel];\n      if (c) image[pixel] = c + 4;\n      if (b) image[pixel] = b + 2;\n      if (a) image[pixel] = a;\n    }\n    return image;\n  }\n\n  decodeSoundFlags() {\n    var arr = new Array(this.frameCount).fill([]);\n    return arr.map(_ => [false, false, false]);\n  }\n\n  hasAudioTrack(trackIndex) {\n    return false;\n  }\n\n}","import player from \"./player\";\nimport parser from \"./parser\";\nimport ppmParser from \"./parser/ppm\";\nimport kwzParser from \"./parser/kwz\";\n\nconst module = {\n  version: VERSION,\n  player,\n  parser,\n  ppmParser,\n  kwzParser,\n};\n\nexport {\n  module as default,\n  parser,\n  ppmParser,\n  kwzParser\n}\n\n","import canvas from \"webgl/canvas\";\nimport parser from \"parser\";\nimport loader from \"loader\";\nimport audioTrack from \"./audio\";\nimport webglCanvas from \"../webgl/canvas\";\n\n/** flipnote player API, based on HTMLMediaElement (https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement) */ \nexport default class flipnotePlayer {\n  /**\n  * Create new flipnote player\n  * @param {string | HTMLCanvasElement} el - HTML Canvas Element to use, or CSS selector for one\n  * @param {number} width - canvas width in pixels\n  * @param {number} height - canvas height in pixels\n  */\n  constructor(el, width, height) {\n    // if `el` is a string, use it to select an Element, else assume it's an element\n    el = (\"string\" == typeof el) ? document.querySelector(el) : el;\n    this.canvas = new canvas(el, width, height);\n    this._imgCanvas = new canvas(document.createElement(\"canvas\"), width, height, {\n      antialias: true,\n      preserveDrawingBuffer: true,\n    });\n    this._isOpen = false;\n    this._events = {};\n    this.loop = false;\n    this.currentFrame = 0;\n    this.paused = true;\n    this.audioTracks = [\n      new audioTrack(\"se1\"),\n      new audioTrack(\"se2\"),\n      new audioTrack(\"se3\"),\n      new audioTrack(\"bgm\"),\n    ];\n    this.smoothRendering = false;\n  }\n\n  /**\n  * Get the index of the current frame \n  */\n  get currentFrame() {\n    return this._frame;\n  }\n\n  /**\n  * Set the current frame\n  */\n  set currentFrame(index) {\n    this.setFrame(index);\n  }\n\n  /**\n  * Get current playback time in seconds\n  */\n  get currentTime() {\n    return this._isOpen ? this.currentFrame * (1 / this.framerate) : null;\n  }\n\n  /**\n  * Set current playback time in seconds\n  */\n  set currentTime(value) {\n    if ((this._isOpen) && (value < this.duration) && (value > 0)) {\n      this.setFrame(Math.round(value / (1 / this.framerate)));\n    }\n  }\n\n  /**\n  * Get audio volume\n  */\n  get volume() {\n    return this.audioTracks[3].audio.volume;\n  }\n\n  /**\n  * Set audio volume\n  */\n  set volume(value) {\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].audio.volume = value;\n    }\n  }\n\n  /**\n  * Get audio mute\n  */\n  get muted() {\n    return this.audioTracks[3].audio.muted;\n  }\n\n  /**\n  * Set audio mute\n  */\n  set muted(value) {\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].audio.muted = value;\n    }\n  }\n\n  /**\n  * Get the duration of the Flipnote in seconds\n  */\n  get duration() {\n    return this._isOpen ? this.frameCount * (1 / this.framerate) : null;\n  }\n\n  /**\n  * Get the Flipnote framerate in frames-per-second\n  */\n  get framerate() {\n    return this.note.framerate;\n  }\n\n  /**\n  * Get the audio playback rate by comparing audio and frame speeds\n  * @access protected\n  */\n  get _audiorate() {\n    return (1 / this.note.bgmrate) / (1 / this.note.framerate);\n  }\n\n  /**\n  * Load a Flipnote into the player\n  * @param {ArrayBuffer} buffer - ppm data\n  * @access protected\n  */\n  _load(buffer) {\n    var note = new parser(buffer);\n    this.note = note;\n    this.meta = note.meta;\n    this.type = note.type;\n    this.frameCount = note.frameCount;\n    this.frameSpeed = note.frameSpeed;\n    this.fileLength = note.byteLength;\n    this.loop = note.meta.loop == 1;\n    this.paused = true;\n    this._isOpen = true;\n    if (this.note.hasAudioTrack(1)) this.audioTracks[0].set(this.note.decodeAudio(\"se1\"), 1);\n    if (this.note.hasAudioTrack(2)) this.audioTracks[1].set(this.note.decodeAudio(\"se2\"), 1);\n    if (this.note.hasAudioTrack(3)) this.audioTracks[2].set(this.note.decodeAudio(\"se3\"), 1);\n    if (this.note.hasAudioTrack(0)) this.audioTracks[3].set(this.note.decodeAudio(\"bgm\"), this._audiorate);\n    this._seFlags = this.note.decodeSoundFlags();\n    this._playbackLoop = null;\n    this._hasPlaybackStarted = false;\n    this.layerVisiblity = {\n      1: true,\n      2: true,\n      3: true\n    };\n    this.setMode(this.type);\n    this.setFrame(this.note.thumbFrameIndex);\n    this.emit(\"load\");\n  }\n\n  /**\n  * Load a Flipnote into the player\n  * @param {String} source - ppm url\n  */\n  open(source) {\n    if (this._isOpen) this.close();\n    return loader(source)\n      .then((buffer) => {\n        this._load(buffer);\n      })\n      .catch((err) => {\n        console.error(\"Error loading Flipnote:\", err);\n      });\n  }\n\n  /**\n  * Close the currently loaded Flipnote and clear the player canvas\n  */\n  close() {\n    this.pause();\n    this.note = null;\n    this._isOpen = false;\n    this.paused = true;\n    this.loop = null;\n    this.meta = null;\n    this.frameCount = null;\n    this.frameSpeed = null;\n    this._frame = 0;\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].unset();\n    }\n    this._seFlags = null;\n    this._hasPlaybackStarted = null;\n    this.canvas.clear();\n    this._imgCanvas.clear();\n  }\n\n  /**\n  * Destroy this player instance cleanly\n  */\n  destroy() {\n    this.close();\n    this.canvas.destroy();\n    this._imgCanvas.destroy();\n  }\n\n  /**\n  * Play the sound effects for a given frame\n  * @param {number} index - zero-based frame index\n  * @access protected\n  */\n  _playFrameSe(index) {\n    var flags = this._seFlags[index];\n    for (let i = 0; i < flags.length; i++) {\n      if (flags[i] && this.audioTracks[i].active) this.audioTracks[i].start();\n    }\n  }\n\n  /**\n  * Play the Flipnote BGM\n  * @access protected\n  */\n  _playBgm() {\n    this.audioTracks[3].start(this.currentTime);\n  }\n\n  /**\n  * Stop all audio tracks\n  * @access protected\n  */\n  _stopAudio() {\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].stop();\n    }\n  }\n\n  /**\n  * Begin Flipnote playback\n  */\n  play() {\n    if ((!this._isOpen) || (!this.paused)) return null;\n    this.paused = false;\n    if ((!this._hasPlaybackStarted) || ((!this.loop) && (this.currentFrame == this.frameCount - 1))) this._frame = 0;\n    this._playBgm();\n    this._playbackLoop = setInterval(() => {\n      if (this.paused) clearInterval(this._playbackLoop);\n      // if the end of the flipnote has been reached\n      if (this.currentFrame >= this.frameCount -1) {\n        this._stopAudio();\n        if (this.loop) {\n          this.firstFrame();\n          this._playBgm(0);\n          this.emit(\"playback:loop\");\n        } else {\n          this.pause();\n          this.emit(\"playback:end\");\n        }\n      } else {\n        this._playFrameSe(this.currentFrame);\n        this.nextFrame();\n      }\n    }, 1000 / this.framerate);\n    this._hasPlaybackStarted = true;\n    this.emit(\"playback:start\");\n  }\n\n  /**\n  * Pause Flipnote playback\n  */\n  pause() {\n    if ((!this._isOpen) || (this.paused)) return null;\n    // break the playback loop\n    clearInterval(this._playbackLoop);\n    this.paused = true;\n    this._stopAudio();\n    this.emit(\"playback:stop\");\n  }\n\n  /**\n  * Get a specific frame as an image data URL\n  * @param {number|string} index - zero-based frame index, or pass \"thumb\" to get the thumbnail frame\n  * @param {string} type - image MIME type, default is image/png\n  * @param {number} encoderOptions - number between 0 and 1 indicating image quality if type is image/jpeg or image/webp\n  */\n  getFrameImage(index, width, height, type, encoderOptions) {\n    if (!this._isOpen) return null;\n    var canvas = this._imgCanvas;\n    if (canvas.width !== width || canvas.height !== height) canvas.setSize(width, height);\n    // clamp frame index\n    index = (index == \"thumb\") ? (this.note.thumbFrameIndex) : (Math.max(0, Math.min(index, this.frameCount - 1)));\n    this.drawFrame(index, canvas);\n    return canvas.toImage(type, encoderOptions);\n  }\n\n  /**\n  * Jump to a specific frame\n  * @param {number} index - zero-based frame index\n  */\n  setFrame(index) {\n    if ((!this._isOpen) || (index === this.currentFrame)) return null;\n    // clamp frame index\n    index = Math.max(0, Math.min(Math.floor(index), this.frameCount - 1));\n    this._frame = index;\n    this._playbackFrameTime = 0;\n    this.drawFrame(index, this.canvas);\n    this.emit(\"frame:update\", this.currentFrame);\n  }\n\n  /**\n  * Draw a frame to a given canvas\n  * @param {number} index - zero-based frame index\n  * @param {webglCanvas} canvas - webgl frame canvas\n  */\n  drawFrame(frameIndex, canvas) {\n    let colors = this.note.getFramePalette(frameIndex);\n    let layerBuffers = this.note.decodeFrame(frameIndex);\n    canvas.setPaperColor(colors[0]);\n    canvas.clear();\n    if (this.note.type == \"PPM\") {\n      if (this.layerVisiblity[2]) canvas.drawLayer(layerBuffers[1], 256, 192, colors[2], [0,0,0,0]);\n      if (this.layerVisiblity[1]) canvas.drawLayer(layerBuffers[0], 256, 192, colors[1], [0,0,0,0]);\n    } else if (this.note.type == \"KWZ\") {\n      if (this.layerVisiblity[3]) canvas.drawLayer(layerBuffers[2], 320, 240, colors[5], colors[6]);\n      if (this.layerVisiblity[2]) canvas.drawLayer(layerBuffers[1], 320, 240, colors[3], colors[4]);\n      if (this.layerVisiblity[1]) canvas.drawLayer(layerBuffers[0], 320, 240, colors[1], colors[2]);\n    }\n  }\n\n  /**\n  * Jump to the thumbnail frame\n  */\n  thumbnailFrame() {\n    this.currentFrame = this.note.thumbFrameIndex;\n  }\n\n  /**\n  * Jump to the next frame in the animation\n  */\n  nextFrame() {\n    if ((this.loop) && (this.currentFrame >= this.frameCount -1)) {\n      this.currentFrame = 0;\n    } else {\n      this.currentFrame += 1;\n    }\n  }\n\n  /**\n  * Jump to the previous frame in the animation\n  */\n  prevFrame() {\n    if ((this.loop) && (this.currentFrame <= 0)) {\n      this.currentFrame = this.frameCount - 1;\n    } else {\n      this.currentFrame -= 1;\n    }\n  }\n\n  /**\n  * Jump to the last frame in the animation\n  */\n  lastFrame() {\n    this.currentFrame = this.frameCount - 1;\n  }\n\n  /**\n  * Jump to the first frame in the animation\n  */\n  firstFrame() {\n    this.currentFrame = 0;\n  }\n\n  /**\n  * Resize player canvas\n  * @param {number} width - canvas width in pixels\n  * @param {number} height - canvas height in pixels\n  */\n  resize(width, height) {\n    this.canvas.resize(width, height);\n    this.forceUpdate();\n  }\n\n  /**\n  * Set layer visibility\n  * @param {number} index - layer number = 1, 2, 3\n  * @param {boolean} value\n  */\n  setLayerVisibility(index, value) {\n    this.layerVisiblity[index] = value;\n    this.forceUpdate();\n  }\n\n  /**\n  * Set smooth rendering\n  * @param {boolean} value\n  */\n  setSmoothRendering(value) {\n    var filter = value ? \"linear\" : \"nearest\";\n    this.canvas.setFilter(filter);\n    this.forceUpdate();\n    this.smoothRendering = value;\n  }\n\n  /**\n  * Set the mode depending on format\n  * @param {string} mode - \"KWZ\" | \"PPM\"\n  */\n  setMode(mode) {\n    this.canvas.setMode(mode);\n    this._imgCanvas.setMode(mode);\n  }\n\n  /**\n  * Force the player to redraw\n  */\n  forceUpdate() {\n    if (this._isOpen) {\n      this.drawFrame(this.currentFrame, this.canvas);\n    }\n  }\n\n  /**\n  * Register an event callback\n  * @param {string} eventType - event type\n  * @param {function} callback - event callback function\n  */\n  on(eventType, callback) {\n    var events = this._events;\n    (events[eventType] || (events[eventType] = [])).push(callback);\n  }\n\n  /**\n  * Remove an event callback\n  * @param {string} eventType - event type\n  * @param {function} callback - event callback function\n  */\n  off(eventType, callback) {\n    var callbackList = this._events[eventType];\n    if (callbackList) callbackList.splice(callbackList.indexOf(callback), 1);\n  }\n\n  /**\n  * Emit an event (used internally)\n  * @param {string} eventType - event type\n  * @param {...} args - arguments to be passed to event callback\n  */\n  emit(eventType, ...args) {\n    var callbackList = this._events[eventType] || [];\n    for (var i = 0; i < callbackList.length; i++) {\n      callbackList[i].apply(null, args); \n    }\n  }\n\n}","module.exports = \"#define GLSLIFY 1\\nattribute vec4 a_position;\\nvarying vec2 v_texcoord;\\nvoid main() {\\n  gl_Position = a_position;\\n  v_texcoord = a_position.xy * vec2(0.5, -0.5) + 0.5;\\n}\"","module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\nvarying vec2 v_texcoord;\\nuniform vec4 u_color1;\\nuniform vec4 u_color2;\\nuniform sampler2D u_bitmap;\\nuniform bool u_isSmooth;\\nvoid main() {\\n  float weightColor1 = texture2D(u_bitmap, v_texcoord).a;\\n  float weightColor2 = texture2D(u_bitmap, v_texcoord).r;\\n  float alpha = 1.0;\\n  if (u_isSmooth) {\\n    weightColor1 = smoothstep(0.0, .9, weightColor1);\\n    weightColor2 = smoothstep(0.0, .9, weightColor2);\\n    float alpha = weightColor1 + weightColor2;\\n  }\\n  gl_FragColor = vec4(u_color1.rgb, alpha) * weightColor1 + vec4(u_color2.rgb, alpha) * weightColor2;\\n}\\n\"","/** convert 4-bit adpcm to 16-bit pcm\n *  implementation based on http://www.cs.columbia.edu/~gskc/Code/AdvancedInternetServices/SoundNoiseRatio/dvi_adpcm.c\n*/\n\nconst indexTable = [\n  -1, -1, -1, -1, 2, 4, 6, 8,\n  -1, -1, -1, -1, 2, 4, 6, 8\n];\n\nconst stepSizeTable = [\n  7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n  19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n  50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n  130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n  337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n  876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n  2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n  5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n  15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n];\n\nlet statePrevSample = 0,\n    statePrevIndex = 0;\n\n/**\n* Convert 4-bit adpcm to 16-bit pcm\n* @param {Uint8Array} inputBuffer - adpcm buffer\n* @returns {Int16Array}\n*/\nexport function decodeAdpcm(inputBuffer) {\n  statePrevSample = 0;\n  statePrevIndex = 0;\n  var outputBuffer = new Int16Array(inputBuffer.length * 2);\n  var outputOffset = 0;\n  for (var inputOffset = 0; inputOffset < inputBuffer.length; inputOffset++) {\n    var byte = inputBuffer[inputOffset];\n    // note - Flipnote Studio's adpcm data uses reverse nibble order\n    outputBuffer[outputOffset] = decodeSample(byte & 0xF);\n    outputBuffer[outputOffset + 1] = decodeSample((byte >> 4) & 0xF);\n    outputOffset += 2;\n  }\n  return outputBuffer;\n};\n\n/**\n* Unpack a single adpcm 4-bit sample\n* @param {number} sample - sample value\n* @returns {number}\n* @access protected\n*/\nfunction decodeSample(sample) {\n  var predSample = statePrevSample;\n  var index = statePrevIndex;\n  var step = stepSizeTable[index];\n  var difference = step >> 3;\n\n  // compute difference and new predicted value\n  if (sample & 0x4) difference += step;\n  if (sample & 0x2) difference += (step >> 1);\n  if (sample & 0x1) difference += (step >> 2);\n  // handle sign bit\n  predSample += (sample & 0x8) ? -difference : difference;\n\n  // find new index value\n  index += indexTable[sample];\n  index = clamp(index, 0, 88);\n\n  // clamp output value\n  predSample = clamp(predSample, -32767, 32767);\n  statePrevSample = predSample;\n  statePrevIndex = index;\n  return predSample;\n};\n\n/**\n* Util to clamp a number within a given range\n* @param {number} num - input value\n* @param {number} min - minimun value\n* @param {number} max - maximum value\n* @returns {number}\n* @access protected\n*/\nfunction clamp(num, min, max) {\n  return num <= min ? min : num >= max ? max : num;\n};","import urlLoader from \"./urlLoader\";\nimport fileLoader from \"./fileLoader\";\nimport arrayBufferLoader from \"./arrayBufferLoader\";\n\nconst loaders = [\n  urlLoader,\n  fileLoader,\n  arrayBufferLoader\n];\n\nexport default function load(source) {\n  return new Promise(function (resolve, reject) {\n    for (var i = 0; i < loaders.length; i++) {\n      var loader = loaders[i];\n      if (loader.matches(source)) {\n        loader.load(source, resolve, reject);\n        break;\n      }\n    }\n  });\n}","export default {\n\n  matches: function(source) {\n    return typeof source === \"string\";\n  },\n\n  load: function(source, resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", source, true);\n    xhr.responseType = \"arraybuffer\"; \n    xhr.onreadystatechange = function (e) {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(xhr.response);\n        } else {\n          reject({\n            type: \"httpError\",\n            status: xhr.status,\n            statusText: xhr.statusText\n          });\n        }\n      }\n    };\n    xhr.send(null);\n  }\n\n}","export default {\n\n  matches: function(source) {\n    return (source instanceof File);\n  },\n\n  load: function(source, resolve, reject) {\n    var reader = new FileReader();\n    reader.onload = (event) => {\n      resolve(event.target.result)\n    };\n    reader.onerror = (event) => {\n      reject({type: \"fileReadError\"});\n    };\n    reader.readAsArrayBuffer(source);\n  }\n\n}","export default {\n\n  matches: function(source) {\n    return (source instanceof ArrayBuffer);\n  },\n\n  load: function(source, resolve, reject) {\n    resolve(source);\n  }\n\n}","import wavEncoder from \"encoders/wav\";\n\nexport default class audioTrack {\n  /**\n  * Create a new audio player\n  */\n  constructor (id) {\n    this.id = id;\n    this.channelCount = 1;\n    this.bitsPerSample = 16;\n    this.sampleRate = 8192;\n    this.playbackRate = 1;\n    this.audio = document.createElement(\"audio\");\n    this.audio.preload = true;\n    this.active = false;\n  }\n\n  /**\n  * Set the audio track\n  * @param {Int16Array} pcmData - mono-channel 16-bit PCM audio\n  * @param {number} playbackRate - audio playback rate (1 = default)\n  */\n  set(pcmData, playbackRate) {\n    // the HTML5 audio element supports PCM audio if it's in a WAV wrapper\n    let wav = new wavEncoder(this.sampleRate * playbackRate, this.channelCount, this.bitsPerSample);\n    wav.writeFrames(pcmData);\n    this.url = window.URL.createObjectURL(wav.getBlob());\n    // use the blob url for the audio element\n    this.audio.src = this.url;\n    this.active = true;\n    this.playbackRate = playbackRate;\n    this.length = pcmData.length;\n  }\n\n  get duration() {\n    return this.audio.duration;\n  }\n\n  /**\n  * Clear the audio track\n  */\n  unset() {\n    if (this.active) {\n      window.URL.revokeObjectURL(this.url);\n      this.audio.src = \"\";\n      this.audio.load();\n      this.active = false;\n      this.playbackRate = 1;\n      this.length = null;\n    }\n  }\n\n  /**\n  * Start audio playback\n  * @param {number} offset - offset to begin playback at\n  */\n  start(offset) {\n    if (this.active) {\n      this.audio.currentTime = offset || 0;\n      this.audio.play();\n    }\n  }\n\n  /**\n  * Stop audio playback\n  */\n  stop() {\n    if (this.active) {\n      this.audio.pause();\n    }\n  }\n}","import dataStream from \"utils/dataStream\";\n\nexport default class wavEncoder {\n  constructor(sampleRate, channels=1, bitsPerSample=16) {\n    this.sampleRate = sampleRate;\n    this.channels = channels;\n    this.bitsPerSample = bitsPerSample;\n    // Write WAV file header\n    // Reference: http://www.topherlee.com/software/pcm-tut-wavformat.html\n    let headerBuffer = new ArrayBuffer(44);\n    let header = new dataStream(headerBuffer);\n    // \"RIFF\" indent\n    header.writeUtf8(\"RIFF\");\n    // filesize (set later)\n    header.writeUint32(0);\n    // \"WAVE\" indent\n    header.writeUtf8(\"WAVE\");\n    // \"fmt \" section header\n    header.writeUtf8(\"fmt \");\n    // fmt section length\n    header.writeUint32(16);\n    // specify audio format is pcm (type 1)\n    header.writeUint16(1);\n    // number of audio channels\n    header.writeUint16(this.channels);\n    // audio sample rate\n    header.writeUint32(this.sampleRate);\n    // byterate = (sampleRate * bitsPerSample * channelCount) / 8\n    header.writeUint32((this.sampleRate * this.bitsPerSample * this.channels) / 8);\n    // blockalign = (bitsPerSample * channels) / 8\n    header.writeUint16((this.bitsPerSample * this.channels) / 8);\n    // bits per sample\n    header.writeUint16(this.bitsPerSample);\n    // \"data\" section header\n    header.writeUtf8(\"data\");\n    // data section length (set later)\n    header.writeUint32(0);\n    this.header = header;\n    this.pcmData = null;\n  }\n\n  writeFrames(pcmData) {\n    let header = this.header;\n    // fill in filesize\n    header.seek(4);\n    header.writeUint32(header.byteLength + pcmData.byteLength);\n    // fill in data section length\n    header.seek(40);\n    header.writeUint32(pcmData.byteLength);\n    this.pcmData = pcmData;\n  }\n\n  getBlob() {\n    return new Blob([this.header.buffer, this.pcmData.buffer], {type: \"audio/wav\"});\n  }\n}"],"sourceRoot":""}