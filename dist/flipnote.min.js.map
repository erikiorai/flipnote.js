{"version":3,"sources":["webpack://flipnote/webpack/universalModuleDefinition","webpack://flipnote/webpack/bootstrap","webpack://flipnote/./utils/dataStream.js","webpack://flipnote/./flipnote.js","webpack://flipnote/./parser/index.js","webpack://flipnote/./parser/ppm.js","webpack://flipnote/./utils/adpcm.js","webpack://flipnote/./parser/kwz.js","webpack://flipnote/./encoders/wav.js","webpack://flipnote/./player/index.js","webpack://flipnote/./webgl/canvas.js","webpack://flipnote/./webgl/shader.vert","webpack://flipnote/./webgl/shader.frag","webpack://flipnote/./loader/index.js","webpack://flipnote/./loader/urlLoader.js","webpack://flipnote/./loader/fileLoader.js","webpack://flipnote/./loader/arrayBufferLoader.js","webpack://flipnote/./player/audio.js","webpack://flipnote/./encoders/bmp.js","webpack://flipnote/./encoders/gif.js","webpack://flipnote/./utils/byteArray.js","webpack://flipnote/./encoders/lzw.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","dataStream","arrayBuffer","_classCallCheck","buffer","_data","DataView","_offset","offset","whence","byteLength","val","getUint8","setUint8","getInt8","setInt8","littleEndian","arguments","length","undefined","getUint16","setUint16","getInt16","setInt16","getUint32","setUint32","getInt32","setInt32","count","bytes","Uint8Array","_this","forEach","byte","writeUint8","reverse","readBytes","hex","push","toString","padStart","join","toUpperCase","chars","str","char","String","fromCharCode","string","charCodeAt","Uint16Array","version","VERSION","player","parser","ppmParser","kwzParser","default","bitmapEncoder","gifEncoder","wavEncoder","magic","_adpcm","FRAMERATES","1","2","3","4","5","6","7","8","WIDTH","HEIGHT","PALETTE","WHITE","BLACK","RED","BLUE","_possibleConstructorReturn","__proto__","getPrototypeOf","type","_decodeHeader","_decodeAnimationHeader","_decodeSoundHeader","_decodeMeta","sampleRate","palette","_layers","_prevLayers","_prevDecodedFrame","readHex","readUtf8","readUint16","unpacked","byteOffset","readUint8","bitOffset","seek","readUint32","_frameDataLength","_soundDataLength","frameCount","lock","thumbIndex","readInt16","rootAuthorName","readUtf16","parentAuthorName","currentAuthorName","parentAuthorId","currentAuthorId","parentFilename","readFilename","currentFilename","rootAuthorId","timestamp","Date","flags","thumbFrameIndex","meta","loop","frame_count","frame_speed","frameSpeed","bgm_speed","bgmSpeed","thumb_index","spinoff","filename","username","fsid","parent","current","_this2","offsetTableLength","_frameOffsets","Uint32Array","map","bgmLen","se1Len","se2Len","se3Len","framerate","bgmrate","soundMeta","bgm","se1","se2","se3","index","header","paperColor","pen","isNewFrame","decodeFrame","isTranslated","translateX","translateY","set","fill","readInt8","layerEncoding","readLineEncoding","layer","layerBitmap","line","chunkOffset","lineType","lineHeader","chunk","pixel","dest","src","y","x","frameIndex","layerIndex","image","layerColor","paletteMap","getFramePalette","color","globalPalette","indexOf","layers","a","trackIndex","id","track","sample","diff","stepIndex","adpcm","output","Int16Array","outputOffset","prevDiff","prevStepIndex","bitPos","ADPCM_SAMPLE_TABLE_4","ADPCM_INDEX_TABLE_4","Math","max","min","_this3","Array","test","width","height","ADPCM_INDEX_TABLE_2","Int8Array","ADPCM_STEP_TABLE","ADPCM_SAMPLE_TABLE_2","step","YELLOW","GREEN","NONE","PALETTE_INDEX_MAP","TABLE_1","TABLE_2","TABLE_3","values","b","LINE_TABLE","e","f","g","h","_bitIndex","_bitValue","load","sections","size","sectionCount","sectionMagic","substring","sectionLength","_decodeFrameMeta","num","nextBits","mask","result","creationTimestamp","modifiedTimestamp","rootFilename","creation_timestamp","frameMeta","frameOffsets","frame","layerSize","frameAuthor","layerDepth","soundFlags","cameraFlag","trackSizes","se4","depths","getLayerDepths","sort","diffingFlag","isPrevFrame","getDiffingFlag","skip","tileOffsetY","tileOffsetX","subTileOffsetY","subTileOffsetX","pixelOffset","pixelBuffer","readBits","lineIndex","pixels","subarray","lineValue","lineIndexA","lineIndexB","pattern","paletteOffset","framePalette","getLayerOrder","getLayerPixels","slice","WavEncoder","channels","bitsPerSample","headerBuffer","ArrayBuffer","writeUtf8","writeUint32","writeUint16","pcmData","Blob","flipnotePlayer","el","document","querySelector","canvas","_imgCanvas","createElement","antialias","preserveDrawingBuffer","_isOpen","_events","currentFrame","paused","customPalette","audioTracks","audioTrack","smoothRendering","note","fileLength","setPalette","hasAudioTrack","decodeAudio","_audiorate","_seFlags","decodeSoundFlags","_playbackLoop","_hasPlaybackStarted","layerVisiblity","setMode","setFrame","emit","source","close","_loader2","then","_load","catch","err","console","error","pause","_frame","unset","clear","destroy","active","start","currentTime","stop","_playBgm","setInterval","clearInterval","_stopAudio","firstFrame","_playFrameSe","nextFrame","encoderOptions","resize","drawFrame","toImage","forceUpdate","floor","_playbackFrameTime","colors","layerBuffers","setPaperColor","drawLayer","filter","setFilter","eventType","callback","events","callbackList","splice","_len","args","_key","apply","duration","round","audio","volume","muted","webglCanvas","params","alpha","gl","getContext","program","createProgram","refs","shaders","textures","buffers","vShader","_createShader","VERTEX_SHADER","vertexShader","fShader","FRAGMENT_SHADER","fragmentShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","log","getProgramInfoLog","deleteProgram","Error","useProgram","vertBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","activeTexture","TEXTURE0","tex","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","uniforms","uniformCount","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","uniform1i","u_bitmap","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","toDataURL","LINEAR","NEAREST","u_isSmooth","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","textureType","ALPHA","LUMINANCE_ALPHA","uniform4f","clearColor","color1","color2","depth","texImage2D","UNSIGNED_BYTE","setColor","drawArrays","TRIANGLES","viewport","COLOR_BUFFER_BIT","texture","deleteTexture","deleteBuffer","Promise","resolve","reject","loaders","loader","matches","urlLoader","fileLoader","arrayBufferLoader","xhr","XMLHttpRequest","open","responseType","onreadystatechange","readyState","status","response","statusText","send","File","reader","FileReader","onload","event","target","onerror","readAsArrayBuffer","channelCount","playbackRate","preload","wav","writeFrames","url","window","URL","createObjectURL","getBlob","revokeObjectURL","play","roundToNearest","ceil","BitmapEncoder","bpp","vWidth","vHeight","fileHeader","dibHeader","writeInt32","pow","setPaletteCount","setCompression","pixelData","pixelsLength","w","srcOffset","destOffset","headerByteLength","setFilelength","setPixelOffset","concat","img","Image","getUrl","flipnote","format","constructor","bmp","setPixels","getFramePixels","_flipnote","_byteArray","_lzw","GifEncoder","delay","repeat","colorDepth","data","ByteArray","paletteSize","writeHeader","writeColorTable","writeNetscapeExt","writeBytes","graphicsControlExt","netscapeExt","desc","LZWEncoder","encode","writeGraphicsControlExt","writeImageDesc","writePixels","getBuffer","gif","flat","init","writeFrame","page","pages","newPage","pageSize","cursor","getData","array","writeByte","HSIZE","masks","initCodeSize","accum","htab","Int32Array","codetab","cur_accum","cur_bits","a_count","remaining","curPixel","free_ent","maxcode","clear_flg","g_init_bits","ClearCode","EOFCode","outs","flush_char","cl_hash","hsize","init_bits","fcode","ent","disp","hsize_reg","hshift","n_bits","get_maxcode","nextPixel","outer_loop","cl_block","compress","code","char_out"],"mappings":"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","file":"flipnote.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flipnote\"] = factory();\n\telse\n\t\troot[\"flipnote\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/** datastream serves as a wrapper around the DataView API to help keep track of the offset into the stream */\nexport default class dataStream {\n  /**\n  * Create a fileReader instance\n  * @param {ArrayBuffer} arrayBuffer - data to read from\n  */\n  constructor(arrayBuffer) {\n    this.buffer = arrayBuffer;\n    this._data = new DataView(arrayBuffer);\n    this._offset = 0;\n  }\n\n  get bytes() {\n    return new Uint8Array(this.buffer);\n  }\n\n  /**\n  * Get the length of the stream\n  * @returns {number}\n  */\n  get byteLength() {\n    return this._data.byteLength;\n  }\n\n  /**\n  * based on the seek method from Python's file objects - https://www.tutorialspoint.com/python/file_seek.htm\n  * @param {number} offset - position of the read pointer within the stream\n  * @param {number} whence - (optional) defaults to absolute file positioning,\n  *                          1 = offset is relative to the current position\n  *                          2 = offset is relative to the stream's end\n  */\n  seek(offset, whence) {\n    switch (whence) {\n      case 2:\n        this._offset = this._data.byteLength + offset;\n        break;\n      case 1:\n        this._offset += offset;\n        break;\n      case 0:\n      default:\n        this._offset = offset;\n        break;\n    }\n  }\n\n  /**\n  * Read an unsigned 8-bit integer from the stream, and automatically increment the offset\n  * @returns {number}\n  */\n  readUint8() {\n    var val = this._data.getUint8(this._offset);\n    this._offset += 1;\n    return val;\n  }\n\n  /**\n  * Write an unsigned 8-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  */\n  writeUint8(value) {\n    this._data.setUint8(this._offset, value);\n    this._offset += 1;\n  }\n\n  /**\n  * Read a signed 8-bit integer from the stream, and automatically increment the offset\n  * @returns {number}\n  */\n  readInt8() {\n    var val = this._data.getInt8(this._offset);\n    this._offset += 1;\n    return val;\n  }\n\n  /**\n  * Write a signed 8-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  */\n  writeInt8(value) {\n    this._data.setInt8(this._offset, value);\n    this._offset += 1;\n  }\n\n  /**\n  * Read an unsigned 16-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readUint16(littleEndian=true) {\n    var val = this._data.getUint16(this._offset, littleEndian);\n    this._offset += 2;\n    return val;\n  }\n\n  /**\n  * Write an unsigned 16-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeUint16(value, littleEndian=true) {\n    this._data.setUint16(this._offset, value, littleEndian);\n    this._offset += 2;\n  }\n\n  /**\n  * Read a signed 16-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readInt16(littleEndian=true) {\n    var val = this._data.getInt16(this._offset, littleEndian);\n    this._offset += 2;\n    return val;\n  }\n\n  /**\n  * Write a signed 16-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeInt16(value, littleEndian=true) {\n    this._data.setInt16(this._offset, value, littleEndian);\n    this._offset += 2;\n  }\n\n  /**\n  * Read an unsigned 32-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readUint32(littleEndian=true) {\n    var val = this._data.getUint32(this._offset, littleEndian);\n    this._offset += 4;\n    return val;\n  }\n\n  /**\n  * Write an unsigned 32-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeUint32(value, littleEndian=true) {\n    this._data.setUint32(this._offset, value, littleEndian);\n    this._offset += 4;\n  }\n\n  /**\n  * Read a signed 32-bit integer from the stream, and automatically increment the offset\n  * @param {boolean} littleEndian - defaults to true, set to false to read data in big endian byte order\n  * @returns {number}\n  */\n  readInt32(littleEndian=true) {\n    var val = this._data.getInt32(this._offset, littleEndian);\n    this._offset += 4;\n    return val;\n  }\n\n  /**\n  * Write a signed 32-bit integer to the stream, and automatically increment the offset\n  * @param {number} value - value to write\n  * @param {boolean} littleEndian - defaults to true, set to false to write data in big endian byte order\n  */\n  writeInt32(value, littleEndian=true) {\n    this._data.setInt32(this._offset, value, littleEndian);\n    this._offset += 4;\n  }\n\n  /**\n  * Read bytes and return an array\n  * @param {number} count - number of bytes to read\n  * @returns {Uint8Array}\n  */\n  readBytes(count) {\n    var bytes = new Uint8Array(this._data.buffer, this._offset, count);\n    this._offset += bytes.byteLength;\n    return bytes;\n  }\n\n  /**\n  * Write bytes from an array\n  * @param {Array} bytes - array of byte values\n  * @returns {Uint8Array}\n  */\n  writeBytes(bytes) {\n    bytes.forEach(byte => this.writeUint8(byte));\n  }\n\n  /**\n  * Read bytes and return a hex string\n  * @param {number} count - number of bytes to read\n  * @param {bool} reverse - pass true to reverse byte order\n  * @returns {string}\n  */\n  readHex(count, reverse=false) {\n    var bytes = this.readBytes(count);\n    let hex = [];\n    for (let i = 0; i < bytes.length; i++) {\n      hex.push(bytes[i].toString(16).padStart(2, \"0\"));\n    }\n    if (reverse) hex.reverse();\n    return hex.join(\"\").toUpperCase();\n  }\n\n  /**\n  * Read (simple) utf8 string\n  * @param {number} count - number of characters to read\n  * @returns {string}\n  */\n  readUtf8(count) {\n    var chars = this.readBytes(count);\n    var str = \"\";\n    for (let i = 0; i < chars.length; i++) {\n      let char = chars[i];\n      if (char == 0) break;\n      str += String.fromCharCode(char);\n    }\n    return str;\n  }\n\n  /**\n  * Write (simple) utf8 string\n  * @param {string} string - string to write\n  */\n  writeUtf8(string) {\n    for (let i = 0; i < string.length; i++) {\n      let char = string.charCodeAt(i);\n      this.writeUint8(char);\n    }\n  }\n\n  /**\n  * Read (simple) utf16 string\n  * @param {number} count - number of characters to read\n  * @returns {string}\n  */\n  readUtf16(count) {\n    var chars = new Uint16Array(this._data.buffer, this._offset, count);\n    this._offset += chars.byteLength;\n    var str = \"\";\n    for (let i = 0; i < chars.length; i++) {\n      let char = chars[i];\n      if (char == 0) break;\n      str += String.fromCharCode(char);\n    }\n    return str;\n  }\n}","import player from \"./player\";\nimport parser from \"./parser\";\nimport ppmParser from \"./parser/ppm\";\nimport kwzParser from \"./parser/kwz\";\nimport bitmapEncoder from \"./encoders/bmp\";\nimport wavEncoder from \"./encoders/wav\";\nimport gifEncoder from \"./encoders/gif\";\nimport dataStream from \"./utils/dataStream\";\n\nconst module = {\n  version: VERSION,\n  player,\n  parser,\n  ppmParser,\n  kwzParser,\n};\n\nexport {\n  module as default,\n  parser,\n  ppmParser,\n  kwzParser,\n  bitmapEncoder,\n  gifEncoder,\n  wavEncoder,\n  dataStream,\n}\n\n","import ppmParser from \"./ppm\";\nimport kwzParser from \"./kwz\";\n\nexport default function parser(arrayBuffer) {\n  // check the buffer's magic to identify which format it uses\n  let data = new DataView(arrayBuffer, 0, 4);\n  let magic = data.getUint32(0);\n  // check if magic is PARA (ppm magic)\n  if (magic == 0x50415241) {\n    return new ppmParser(arrayBuffer);\n  } \n  // check if magic is KFH (kwz magic)\n  else if ((magic & 0xFFFFFF00) == 0x4B464800) {\n    return new kwzParser(arrayBuffer);\n  }\n  return null;\n}","/**\n * PPM decoder\n * Reads frames, audio, and metadata from Flipnote Studio PPM files \n * Based on my Python PPM decoder implementation (https://github.com/jaames/flipnote-tools)\n *  \n * Credits:\n *  PPM format reverse-engineering and documentation:\n *   - bricklife (http://ugomemo.g.hatena.ne.jp/bricklife/20090307/1236391313)\n *   - mirai-iro (http://mirai-iro.hatenablog.jp/entry/20090116/ugomemo_ppm)\n *   - harimau_tigris (http://ugomemo.g.hatena.ne.jp/harimau_tigris)\n *   - steven (http://www.dsibrew.org/wiki/User:Steven)\n *   - yellows8 (http://www.dsibrew.org/wiki/User:Yellows8)\n *   - PBSDS (https://github.com/pbsds)\n *   - jaames (https://github.com/jaames)\n *  Identifying the PPM sound codec:\n *   - Midmad from Hatena Haiku\n *   - WDLMaster from hcs64.com\n *  Helping me to identify issues with the Python decoder that this is based on:\n *   - Austin Burk (https://sudomemo.net)\n * \n *  Lastly, a huge thanks goes to Nintendo for creating Flipnote Studio, \n *  and to Hatena for providing the Flipnote Hatena online service, both of which inspired so many c:\n*/\n\nimport dataStream from \"utils/dataStream\";\n\nimport {\n  ADPCM_INDEX_TABLE_4,\n  ADPCM_SAMPLE_TABLE_4\n} from \"utils/adpcm\";\n\n// internal framerate value -> FPS table\nconst FRAMERATES = {\n  1: 0.5,\n  2: 1,\n  3: 2,\n  4: 4,\n  5: 6,\n  6: 12,\n  7: 20,\n  8: 30,\n};\n\nconst WIDTH = 256;\nconst HEIGHT = 192;\n\nconst PALETTE = {\n  WHITE: [0xff, 0xff, 0xff],\n  BLACK: [0x0e, 0x0e, 0x0e],\n  RED:   [0xff, 0x2a, 0x2a],\n  BLUE:  [0x0a, 0x39, 0xff],\n};\n\nexport default class ppmParser extends dataStream {\n  /**\n  * Create a ppmDecoder instance\n  * @param {ArrayBuffer} arrayBuffer - data to read from\n  */\n  constructor(arrayBuffer) {\n    super(arrayBuffer);\n    this.type = \"PPM\";\n    this._decodeHeader();\n    this._decodeAnimationHeader();\n    this._decodeSoundHeader();\n    this._decodeMeta();\n    this.sampleRate = 8192;\n    this.palette = PALETTE;\n    // create image buffers\n     this._layers = [\n      new Uint8Array(WIDTH * HEIGHT),\n      new Uint8Array(WIDTH * HEIGHT)\n    ];\n    this._prevLayers = [\n      new Uint8Array(WIDTH * HEIGHT),\n      new Uint8Array(WIDTH * HEIGHT)\n    ];\n    this._prevDecodedFrame = null;\n  }\n\n  static validateFSID(fsid) {\n    return /[0159]{1}[0-9A-F]{6}0[0-9A-F]{8}/.test(fsid);\n  }\n\n  static validateFilename(filename) {\n    return /[0-9A-F]{6}_[0-9A-F]{13}_[0-9]{3}/.test(filename);\n  }\n\n  /**\n  * Read a packed filename\n  * @returns {string}\n  * @access protected\n  */\n  readFilename() {\n    return [\n      this.readHex(3),\n      this.readUtf8(13),\n      this.readUint16().toString().padStart(3, \"0\")\n    ].join(\"_\");\n  }\n\n  /**\n  * Unpack the line encoding flags for all 192 lines in a layer\n  * @returns {array}\n  * @access protected\n  */\n  readLineEncoding() {\n    var unpacked = new Uint8Array(HEIGHT);\n    for (var byteOffset = 0; byteOffset < 48; byteOffset ++) {\n      var byte = this.readUint8();\n      // each line's encoding type is stored as a 2-bit value\n      for (var bitOffset = 0; bitOffset < 8; bitOffset += 2) {\n        unpacked[byteOffset * 4 + bitOffset / 2] = (byte >> bitOffset) & 0x03;\n      }\n    }\n    return unpacked;\n  }\n\n  _decodeHeader() {\n    this.seek(0);\n    // decode header\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#file-header\n    let magic = this.readUint32();\n    this._frameDataLength = this.readUint32();\n    this._soundDataLength = this.readUint32();\n    this.frameCount = this.readUint16() + 1;\n    this.version = this.readUint16();\n  }\n\n  _decodeMeta() {\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#file-header\n    this.seek(0x10);\n    var lock = this.readUint16(),\n        thumbIndex = this.readInt16(),\n        rootAuthorName = this.readUtf16(11),\n        parentAuthorName = this.readUtf16(11),\n        currentAuthorName = this.readUtf16(11),\n        parentAuthorId = this.readHex(8, true),\n        currentAuthorId = this.readHex(8, true),\n        parentFilename = this.readFilename(),\n        currentFilename = this.readFilename(),\n        rootAuthorId = this.readHex(8, true);\n    this.seek(0x9A);\n    var timestamp = new Date((this.readUint32() + 946684800) * 1000);\n    this.seek(0x06A6);\n    var flags = this.readUint16();\n    this.thumbFrameIndex = thumbIndex;\n    this.meta = {\n      lock: lock,\n      loop: flags >> 1 & 0x01,\n      frame_count: this.frameCount,\n      frame_speed: this.frameSpeed,\n      bgm_speed: this.bgmSpeed,\n      thumb_index: thumbIndex,\n      timestamp: timestamp,\n      spinoff: (currentAuthorId !== parentAuthorId) || (currentAuthorId !== rootAuthorId),\n      root: {\n        filename: null,\n        username: rootAuthorName,\n        fsid: rootAuthorId,\n      },\n      parent: {\n        username: parentAuthorName,\n        fsid: parentAuthorId,\n        filename: parentFilename\n      },\n      current: {\n        username: currentAuthorName,\n        fsid: currentAuthorId,\n        filename: currentFilename\n      },\n    };\n  }\n\n  _decodeAnimationHeader() {\n    // jump to the start of the animation data section\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#animation-data-section\n    this.seek(0x06A0);\n    var offsetTableLength = this.readUint16();\n    // skip padding + flags\n    this.seek(0x06A8);\n    // read frame offsets and build them into a table\n    this._frameOffsets = new Uint32Array(offsetTableLength / 4).map(value => {\n      return 0x06A8 + offsetTableLength + this.readUint32();\n    });\n  }\n\n  _decodeSoundHeader() {\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#sound-data-section\n    // offset = frame data offset + frame data length + sound effect flags\n    var offset = 0x06A0 + this._frameDataLength + this.frameCount;\n    // account for multiple-of-4 padding\n    if (offset % 2 != 0) offset += 4 - (offset % 4);\n    this.seek(offset);\n    var bgmLen = this.readUint32();\n    var se1Len = this.readUint32();\n    var se2Len = this.readUint32();\n    var se3Len = this.readUint32();\n    this.frameSpeed = 8 - this.readUint8();\n    this.bgmSpeed = 8 - this.readUint8();\n    offset += 32;\n    this.framerate = FRAMERATES[this.frameSpeed];\n    this.bgmrate = FRAMERATES[this.bgmSpeed];\n    this.soundMeta = {\n      \"bgm\": {offset: offset,           length: bgmLen},\n      \"se1\": {offset: offset += bgmLen, length: se1Len},\n      \"se2\": {offset: offset += se1Len, length: se2Len},\n      \"se3\": {offset: offset += se2Len, length: se3Len},\n    };\n  }\n\n  /**\n  * Check whether or not a given frame is based on the previous one\n  * @param {number} index - zero-based frame index \n  * @returns {boolean}\n  */\n  isNewFrame(index) {\n    this.seek(this._frameOffsets[index]);\n    var header = this.readUint8();\n    return (header >> 7) & 0x1;\n  }\n\n  /**\n  * Get the color palette for a given frame\n  * @param {number} index - zero-based frame index \n  * @returns {array} rgba palette in order of paper, layer1, layer2\n  */\n  getFramePalette(index) {\n    this.seek(this._frameOffsets[index]);\n    const palette = this.palette;\n    var header = this.readUint8();\n    var paperColor = header & 0x1;\n    var pen = [\n      palette.BLACK,\n      paperColor == 1 ? palette.BLACK : palette.WHITE,\n      palette.RED,\n      palette.BLUE,\n    ];\n    return [\n      paperColor == 1 ? palette.WHITE : palette.BLACK,\n      pen[(header >> 1) & 0x3], // layer 1 color\n      pen[(header >> 3) & 0x3], // layer 2 color\n    ];\n  }\n\n  /**\n  * Decode a frame\n  * @param {number} index - zero-based frame index \n  * @returns {array} - 2 uint8 arrays representing each layer\n  * */\n  decodeFrame(index) {\n    if ((index !== 0) && (this._prevDecodedFrame !== index - 1) && (!this.isNewFrame(index)))\n      this.decodeFrame(index - 1);\n    // https://github.com/pbsds/hatena-server/wiki/PPM-format#animation-frame\n    this.seek(this._frameOffsets[index]);\n    var header = this.readUint8();\n    var isNewFrame = (header >> 7) & 0x1;\n    var isTranslated = (header >> 5) & 0x3;\n    var translateX = 0;\n    var translateY = 0;\n    // copy the current layer buffers to the previous ones\n    this._prevLayers[0].set(this._layers[0]);\n    this._prevLayers[1].set(this._layers[1]);\n    this._prevDecodedFrame = index;\n    // reset current layer buffers\n    this._layers[0].fill(0);\n    this._layers[1].fill(0);\n\n    if (isTranslated) {\n      translateX = this.readInt8();\n      translateY = this.readInt8();\n    }\n\n    var layerEncoding = [\n      this.readLineEncoding(),\n      this.readLineEncoding(),\n    ];\n     // start decoding layer bitmaps\n    for (var layer = 0; layer < 2; layer++) {\n      var layerBitmap = this._layers[layer];\n      for (var line = 0; line < HEIGHT; line++) {\n        var chunkOffset = line * WIDTH;\n        var lineType = layerEncoding[layer][line];\n        switch(lineType) {\n          // line type 0 = blank line, decode nothing\n          case 0:\n            break;\n          // line types 1 + 2 = compressed bitmap line\n          case 1:\n          case 2:\n            var lineHeader = this.readUint32(false);\n            // line type 2 starts as an inverted line\n            if (lineType == 2) layerBitmap.fill(0xFF, chunkOffset, chunkOffset + WIDTH);\n            // loop through each bit in the line header\n            while (lineHeader & 0xFFFFFFFF) {\n              // if the bit is set, this 8-pix wide chunk is stored\n              // else we can just leave it blank and move on to the next chunk\n              if (lineHeader & 0x80000000) {\n                var chunk = this.readUint8();\n                // unpack chunk bits\n                for (var pixel = 0; pixel < 8; pixel++) {\n                  layerBitmap[chunkOffset + pixel] = (chunk >> pixel & 0x1) ? 0xFF : 0x00;\n                }\n              }\n              chunkOffset += 8;\n              // shift lineheader to the left by 1 bit, now on the next loop cycle the next bit will be checked\n              lineHeader <<= 1;\n            }\n            break;\n          // line type 3 = raw bitmap line\n          case 3:\n            while(chunkOffset < (line + 1) * WIDTH) {\n              var chunk = this.readUint8();\n              for (var pixel = 0; pixel < 8; pixel++) {\n                layerBitmap[chunkOffset + pixel] = (chunk >> pixel & 0x1) ? 0xFF : 0x00;\n              }\n              chunkOffset += 8;\n            }\n            break;\n        }\n      }\n    }\n    // if the current frame is based on changes from the preivous one, merge them by XORing their values\n    if (!isNewFrame) {\n      var dest, src;\n      // loop through each line\n      for (var y = 0; y < HEIGHT; y++) {\n        // skip to next line if this one falls off the top edge of the screen\n        if (y - translateY < 0) continue;\n        // stop once the bottom screen edge has been reached\n        if (y - translateY >= HEIGHT) break;\n        // loop through each pixel in the line\n        for (var x = 0; x < WIDTH; x++) {\n          // skip to the next pixel if this one falls off the left edge of the screen\n          if (x - translateX < 0) continue;\n          // stop diffing this line once the right screen edge has been reached\n          if (x - translateX >= WIDTH) break;\n          dest = x + y * WIDTH;\n          src = dest - (translateX + translateY * WIDTH);\n          // diff pixels with a binary XOR\n          this._layers[0][dest] ^= this._prevLayers[0][src];\n          this._layers[1][dest] ^= this._prevLayers[1][src];\n        }\n      }\n    }\n    return this._layers;\n  }\n\n  // retuns an uint8 array where each item is a pixel's palette index\n  getLayerPixels(frameIndex, layerIndex) {\n    if (this._prevDecodedFrame !== frameIndex) {\n      this.decodeFrame(frameIndex);\n    }\n    const layer = this._layers[layerIndex];\n    const image = new Uint8Array((256 * 192));\n    const layerColor = layerIndex + 1\n    for (let pixel = 0; pixel < image.length; pixel++) {\n      if (layer[pixel] !== 0) {\n        image[pixel] = layerColor;\n      }\n    }\n    return image;\n  }\n\n  // retuns an uint8 array where each item is a pixel's palette index\n  getFramePixels(frameIndex, useGlobalPalette = false) {\n    let paletteMap;\n    if (useGlobalPalette) {\n      const framePalette = this.getFramePalette(frameIndex);\n      paletteMap = framePalette.map(color => ppmParser.globalPalette.indexOf(color));\n    } else {\n      paletteMap = [0, 1, 2];\n    }\n    const layers = this.decodeFrame(frameIndex);\n    const image = new Uint8Array((256 * 192));\n    image.fill(paletteMap[0]);\n    for (let pixel = 0; pixel < image.length; pixel++) {\n      let a = layers[0][pixel];\n      let b = layers[1][pixel];\n      if (b) image[pixel] = paletteMap[2];\n      if (a) image[pixel] = paletteMap[1];\n    }\n    return image;\n  }\n\n  hasAudioTrack(trackIndex) {\n    let id = [\"bgm\", \"se1\", \"se2\", \"se3\"][trackIndex];\n    return this.soundMeta[id].length > 0;\n  }\n\n  /**\n  * Decode an audio track to 32-bit adpcm\n  * @param {string} track - track name, \"bgm\" | \"se1\" | \"se2\" | \"se3\"\n  * @returns {Int16Array}\n  */\n  decodeAudio(track) {\n    let meta = this.soundMeta[track];\n    let adpcm = new Uint8Array(this.buffer, meta.offset, meta.length);\n    let output = new Int16Array(adpcm.length * 2);\n    let outputOffset = 0;\n    // initial decoder state\n    var prevDiff = 0;\n    var prevStepIndex = 0;\n    var sample, diff, stepIndex;\n    // loop through each byte in the raw adpcm data\n    for (let index = 0; index < adpcm.length; index++) {\n      let byte = adpcm[index];\n      var bitPos = 0;\n      while (bitPos < 8) {\n        // isolate 4-bit sample\n        sample = (byte >> bitPos) & 0xF;\n        // get diff\n        diff = prevDiff + ADPCM_SAMPLE_TABLE_4[sample + 16 * prevStepIndex];\n        // get step index\n        stepIndex = prevStepIndex + ADPCM_INDEX_TABLE_4[sample];\n        // clamp step index and diff\n        stepIndex = Math.max(0, Math.min(stepIndex, 79));\n        diff = Math.max(-32767, Math.min(diff, 32767));\n        // add result to output buffer\n        output[outputOffset] = (diff);\n        outputOffset += 1;\n        // set prev decoder state\n        prevStepIndex = stepIndex;\n        prevDiff = diff;\n        // move to next sample\n        bitPos += 4;\n      }\n    }\n    return output;\n  }\n\n  /**\n  * Decode the sound effect usage for each frame\n  * @returns {array}\n  */\n  decodeSoundFlags() {\n    this.seek(0x06A0 + this._frameDataLength);\n    // per msdn docs - the array map callback is only invoked for array indicies that have assigned values\n    // so when we create an array, we need to fill it with something before we can map over it\n    var arr = new Array(this.frameCount).fill([]);\n    return arr.map(value => {\n      var byte = this.readUint8();\n      return [byte & 0x1, (byte >> 1) & 0x1, (byte >> 2) & 0x1];\n    });\n  }\n}\n\nppmParser.width = WIDTH;\nppmParser.height = HEIGHT;\nppmParser.globalPalette = [\n  PALETTE.BLACK,\n  PALETTE.WHITE,\n  PALETTE.RED,\n  PALETTE.BLUE\n];","export const ADPCM_INDEX_TABLE_2 = new Int8Array([\n  -1, 2, -1, 2\n]);\n\nexport const ADPCM_INDEX_TABLE_4 = new Int8Array([\n  -1, -1, -1, -1, 2, 4, 6, 8,\n  -1, -1, -1, -1, 2, 4, 6, 8\n]);\n\n// note that this is a slight deviation from the normal adpcm table\nexport const ADPCM_STEP_TABLE = new Int16Array([\n  7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n  19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n  50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n  130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n  337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n  876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n  2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n  5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n  15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767, 0\n]);\n\nexport const ADPCM_SAMPLE_TABLE_2 = new Int16Array(90 * 4);\nfor (let sample = 0; sample < 4; sample++) {\n  for (let stepIndex = 0; stepIndex < 90; stepIndex++) {\n    let step = ADPCM_STEP_TABLE[stepIndex];\n    let diff = step >> 3;\n    if (sample & 1) diff += step;\n    if (sample & 2) diff = -diff;\n    ADPCM_SAMPLE_TABLE_2[sample + 4 * stepIndex] = diff;\n  }\n}\n\nexport const ADPCM_SAMPLE_TABLE_4 = new Int16Array(90 * 16);\nfor (let sample = 0; sample < 16; sample++) {\n  for (let stepIndex = 0; stepIndex < 90; stepIndex++) {\n    let step = ADPCM_STEP_TABLE[stepIndex];\n    let diff = step >> 3;\n    if (sample & 4) diff += step;\n    if (sample & 2) diff += step >> 1;\n    if (sample & 1) diff += step >> 2;\n    if (sample & 8) diff = -diff;\n    ADPCM_SAMPLE_TABLE_4[sample + 16 * stepIndex] = diff;\n  }\n}","import dataStream from \"utils/dataStream\";\n\nimport {\n  ADPCM_INDEX_TABLE_2,\n  ADPCM_INDEX_TABLE_4,\n  ADPCM_SAMPLE_TABLE_2,\n  ADPCM_SAMPLE_TABLE_4\n} from \"utils/adpcm\";\n\nconst FRAMERATES = [\n  0.2,\n  0.5,\n  1,\n  2,\n  4, \n  6,\n  8,\n  12, \n  20,\n  24,\n  30\n];\n\nconst PALETTE = {\n  WHITE:  [0xff, 0xff, 0xff],\n  BLACK:  [0x10, 0x10, 0x10],\n  RED:    [0xff, 0x10, 0x10],\n  YELLOW: [0xff, 0xe7, 0x00],\n  GREEN:  [0x00, 0x86, 0x31],\n  BLUE:   [0x00, 0x38, 0xce],\n  NONE:   [0xff, 0xff, 0xff]\n};\n\nconst PALETTE_INDEX_MAP = [\n  'WHITE',\n  'BLACK',\n  'RED',\n  'YELLOW',\n  'GREEN',\n  'BLUE',\n  'NONE'\n];\n\n// table1 - commonly occuring line offsets\nconst TABLE_1 = new Uint16Array([\n  0x0000, 0x0CD0, 0x19A0, 0x02D9, 0x088B, 0x0051, 0x00F3, 0x0009,\n  0x001B, 0x0001, 0x0003, 0x05B2, 0x1116, 0x00A2, 0x01E6, 0x0012,\n  0x0036, 0x0002, 0x0006, 0x0B64, 0x08DC, 0x0144, 0x00FC, 0x0024,\n  0x001C, 0x0004, 0x0334, 0x099C, 0x0668, 0x1338, 0x1004, 0x166C\n]);\n// table2 - commonly occuring line offsets, but the lines are shifted to the left by one pixel\nconst TABLE_2 = new Uint16Array([\n  0x0000, 0x0CD0, 0x19A0, 0x0003, 0x02D9, 0x088B, 0x0051, 0x00F3, \n  0x0009, 0x001B, 0x0001, 0x0006, 0x05B2, 0x1116, 0x00A2, 0x01E6, \n  0x0012, 0x0036, 0x0002, 0x02DC, 0x0B64, 0x08DC, 0x0144, 0x00FC, \n  0x0024, 0x001C, 0x099C, 0x0334, 0x1338, 0x0668, 0x166C, 0x1004\n]);\n// table3 - line offsets, but the lines are shifted to the left by one pixel\nconst TABLE_3 = new Uint16Array(6561);\nvar values = [0, 3, 7, 1, 4, 8, 2, 5, 6];\nlet index = 0;\nfor (let a = 0; a < 9; a++)\n  for (let b = 0; b < 9; b++)\n    for (let c = 0; c < 9; c++)\n      for (let d = 0; d < 9; d++) {\n        TABLE_3[index] = ((values[a] * 9 + values[b]) * 9 + values[c]) * 9 + values[d];\n        index++;\n      }\n\n// linetable - contains every possible sequence of pixels for each tile line\nconst LINE_TABLE = new Uint16Array(6561 * 8);\nvar values = [0x0000, 0xFF00, 0x00FF];\nlet offset = 0;\nfor (let a = 0; a < 3; a++)\n  for (let b = 0; b < 3; b++)\n    for (let c = 0; c < 3; c++)\n      for (let d = 0; d < 3; d++)\n        for (let e = 0; e < 3; e++)\n          for (let f = 0; f < 3; f++)\n            for (let g = 0; g < 3; g++)\n              for (let h = 0; h < 3; h++) {\n                LINE_TABLE.set([\n                  values[b], \n                  values[a], \n                  values[d], \n                  values[c], \n                  values[f], \n                  values[e], \n                  values[h], \n                  values[g]\n                ], offset);\n                offset += 8;\n              }\n\nexport default class kwzParser extends dataStream {\n\n  constructor(arrayBuffer) {\n    super(arrayBuffer);\n    this.type = \"KWZ\";\n    this._layers = [\n      new Uint16Array(320 * 240),\n      new Uint16Array(320 * 240),\n      new Uint16Array(320 * 240),\n    ];\n    this._bitIndex = 0;\n    this._bitValue = 0;\n    this.load();\n  }\n\n  load() {\n    this.seek(0);\n    this.sections = {};\n    let size = this.byteLength - 256;\n    let offset = 0;\n    let sectionCount = 0;\n    // counting sections should mitigate against one of mrnbayoh's notehax exploits\n    while ((offset < size) && (sectionCount < 6)) {\n      this.seek(offset);\n      let sectionMagic = this.readUtf8(4).substring(0, 3);\n      let sectionLength = this.readUint32();\n      this.sections[sectionMagic] = {\n        offset: offset,\n        length: sectionLength\n      };\n      offset += sectionLength + 8;\n      sectionCount += 1;\n    }\n\n    this._decodeMeta();\n    this._decodeFrameMeta();\n    this._decodeSoundHeader();\n    this.sampleRate = 16364;\n    this.palette = PALETTE;\n    this._prevDecodedFrame = null;\n  }\n\n  readBits(num) {\n    if (this._bitIndex + num > 16) {\n      let nextBits = this.readUint16();\n      this._bitValue |= nextBits << (16 - this._bitIndex);\n      this._bitIndex -= 16;\n    }\n    let mask = (1 << num) - 1;\n    let result = this._bitValue & mask;\n    this._bitValue >>= num;\n    this._bitIndex += num;\n    return result;\n  }\n\n  _decodeMeta() {\n    this.seek(this.sections[\"KFH\"].offset + 12);\n    let creationTimestamp = new Date((this.readUint32() + 946684800) * 1000),\n        modifiedTimestamp = new Date((this.readUint32() + 946684800) * 1000),\n        appVersion = this.readUint32(),\n        rootAuthorId = this.readHex(10),\n        parentAuthorId = this.readHex(10),\n        currentAuthorId = this.readHex(10),\n        rootAuthorName = this.readUtf16(11),\n        parentAuthorName = this.readUtf16(11),\n        currentAuthorName = this.readUtf16(11),\n        rootFilename = this.readUtf8(28),\n        parentFilename = this.readUtf8(28),\n        currentFilename = this.readUtf8(28),\n        frameCount = this.readUint16(),\n        thumbIndex = this.readUint16(),\n        flags = this.readUint16(),\n        frameSpeed = this.readUint8(),\n        layerFlags = this.readUint8();\n    this.frameCount = frameCount;\n    this.thumbFrameIndex = thumbIndex;\n    this.frameSpeed = frameSpeed;\n    this.framerate = FRAMERATES[frameSpeed];\n    this.meta = {\n      lock: flags & 0x1,\n      loop: (flags >> 1) & 0x01,\n      frame_count: frameCount,\n      frame_speed: frameSpeed,\n      thumb_index: thumbIndex,\n      timestamp: modifiedTimestamp,\n      creation_timestamp: creationTimestamp,\n      root: {\n        username: rootAuthorName,\n        fsid: rootAuthorId,\n        filename: rootFilename,\n      },\n      parent: {\n        username: parentAuthorName,\n        fsid: parentAuthorId,\n        filename: parentFilename,\n      },\n      current: {\n        username: currentAuthorName,\n        fsid: currentAuthorId,\n        filename: currentFilename,\n      },\n    };\n  }\n\n  _decodeFrameMeta() {\n    this.frameMeta = [];\n    this.frameOffsets = [];\n    this.seek(this.sections[\"KMI\"].offset + 8);\n    offset = this.sections[\"KMC\"].offset + 12;\n    for (let i = 0; i < this.frameCount; i++) {\n      let frame = {\n        flags: this.readUint32(),\n        layerSize: [\n          this.readUint16(),\n          this.readUint16(),\n          this.readUint16()\n        ],\n        frameAuthor: this.readHex(10),\n        layerDepth: [\n          this.readUint8(),\n          this.readUint8(),\n          this.readUint8(),\n        ],\n        soundFlags: this.readUint8(),\n        cameraFlag: this.readUint32(),\n      };\n      this.frameMeta.push(frame);\n      this.frameOffsets.push(offset);\n      offset += frame.layerSize[0] + frame.layerSize[1] + frame.layerSize[2];\n    }\n  }\n\n  _decodeSoundHeader() {\n    let offset = this.sections[\"KSN\"].offset + 8;\n    this.seek(offset);\n    let bgmSpeed = this.readUint32();\n    this.bgmSpeed = bgmSpeed;\n    this.bgmrate = FRAMERATES[bgmSpeed];\n    let trackSizes = new Uint32Array(this.buffer, offset + 4, 20);\n    this.soundMeta = {\n      \"bgm\": {offset: offset += 28,            length: trackSizes[0]},\n      \"se1\": {offset: offset += trackSizes[0], length: trackSizes[1]},\n      \"se2\": {offset: offset += trackSizes[1], length: trackSizes[2]},\n      \"se3\": {offset: offset += trackSizes[2], length: trackSizes[3]},\n      \"se4\": {offset: offset += trackSizes[3], length: trackSizes[4]},\n    };\n  }\n\n  getDiffingFlag(frameIndex) {\n    return ~(this.frameMeta[frameIndex].flags >> 4) & 0x07;\n  }\n\n  getLayerDepths(frameIndex) {\n    return this.frameMeta[frameIndex].layerDepth;\n  }\n\n  // sort layer indices sorted by depth, drom bottom to top\n  getLayerOrder(frameIndex) {\n    const depths = this.getLayerDepths(frameIndex);\n    return [2, 1, 0].sort((a, b) => depths[b] - depths[a]);\n  }\n\n  decodeFrame(frameIndex, diffingFlag=0x7, isPrevFrame=false) {\n    // if this frame is being decoded as a prev frame, then we only want to decode the layers necessary\n    if (isPrevFrame)\n      diffingFlag &= this.getDiffingFlag(frameIndex + 1);\n    // the prevDecodedFrame check is an optimisation for decoding frames in full sequence\n    if ((frameIndex !== 0) && (this._prevDecodedFrame !== frameIndex - 1) && (diffingFlag))\n      this.decodeFrame(frameIndex - 1, diffingFlag=diffingFlag, isPrevFrame=true);\n\n    let meta = this.frameMeta[frameIndex];\n    let offset = this.frameOffsets[frameIndex];\n\n    for (let layerIndex = 0; layerIndex < 3; layerIndex++) {\n      this.seek(offset);\n      let layerSize = meta.layerSize[layerIndex];\n      offset += layerSize;\n\n      // if the layer is 38 bytes then it hasn't changed at all since the previous frame, so we can skip it\n      if (layerSize === 38) continue;\n\n      if ((diffingFlag >> layerIndex) & 0x1 === 0) continue;\n\n      this._bitIndex = 16;\n      this._bitValue = 0;\n      let skip = 0;\n\n      for (let tileOffsetY = 0; tileOffsetY < 240; tileOffsetY += 128) {\n        for (let tileOffsetX = 0; tileOffsetX < 320; tileOffsetX += 128) {\n          for (let subTileOffsetY = 0; subTileOffsetY < 128; subTileOffsetY += 8) {\n            let y = tileOffsetY + subTileOffsetY;\n            if (y >= 240) break;\n\n            for (let subTileOffsetX = 0; subTileOffsetX < 128; subTileOffsetX += 8) {\n              let x = tileOffsetX + subTileOffsetX;\n              if (x >= 320) break;\n\n              if (skip) {\n                skip -= 1;\n                continue;\n              }\n\n              let pixelOffset = y * 320 + x;\n              let pixelBuffer = this._layers[layerIndex];\n\n              let type = this.readBits(3);\n\n              if (type == 0) {\n                let lineIndex = TABLE_1[this.readBits(5)];\n                let pixels = LINE_TABLE.subarray(lineIndex * 8, lineIndex * 8 + 8);\n                pixelBuffer.set(pixels, pixelOffset);\n                pixelBuffer.set(pixels, pixelOffset + 320);\n                pixelBuffer.set(pixels, pixelOffset + 640);\n                pixelBuffer.set(pixels, pixelOffset + 960);\n                pixelBuffer.set(pixels, pixelOffset + 1280);\n                pixelBuffer.set(pixels, pixelOffset + 1600);\n                pixelBuffer.set(pixels, pixelOffset + 1920);\n                pixelBuffer.set(pixels, pixelOffset + 2240);\n              } \n\n              else if (type == 1) {\n                let lineIndex = this.readBits(13);\n                let pixels = LINE_TABLE.subarray(lineIndex * 8, lineIndex * 8 + 8);\n                pixelBuffer.set(pixels, pixelOffset);\n                pixelBuffer.set(pixels, pixelOffset + 320);\n                pixelBuffer.set(pixels, pixelOffset + 640);\n                pixelBuffer.set(pixels, pixelOffset + 960);\n                pixelBuffer.set(pixels, pixelOffset + 1280);\n                pixelBuffer.set(pixels, pixelOffset + 1600);\n                pixelBuffer.set(pixels, pixelOffset + 1920);\n                pixelBuffer.set(pixels, pixelOffset + 2240);\n              } \n              \n              else if (type == 2) {\n                let lineValue = this.readBits(5);\n                let lineIndexA = TABLE_1[lineValue];\n                let lineIndexB = TABLE_2[lineValue];\n                let a = LINE_TABLE.subarray(lineIndexA * 8, lineIndexA * 8 + 8);\n                let b = LINE_TABLE.subarray(lineIndexB * 8, lineIndexB * 8 + 8);\n                pixelBuffer.set(a, pixelOffset);\n                pixelBuffer.set(b, pixelOffset + 320);\n                pixelBuffer.set(a, pixelOffset + 640);\n                pixelBuffer.set(b, pixelOffset + 960);\n                pixelBuffer.set(a, pixelOffset + 1280);\n                pixelBuffer.set(b, pixelOffset + 1600);\n                pixelBuffer.set(a, pixelOffset + 1920);\n                pixelBuffer.set(b, pixelOffset + 2240);\n              } \n              \n              else if (type == 3) {\n                let lineIndexA = this.readBits(13);\n                let lineIndexB = TABLE_3[lineIndexA];\n                let a = LINE_TABLE.subarray(lineIndexA * 8, lineIndexA * 8 + 8);\n                let b = LINE_TABLE.subarray(lineIndexB * 8, lineIndexB * 8 + 8);\n                pixelBuffer.set(a, pixelOffset);\n                pixelBuffer.set(b, pixelOffset + 320);\n                pixelBuffer.set(a, pixelOffset + 640);\n                pixelBuffer.set(b, pixelOffset + 960);\n                pixelBuffer.set(a, pixelOffset + 1280);\n                pixelBuffer.set(b, pixelOffset + 1600);\n                pixelBuffer.set(a, pixelOffset + 1920);\n                pixelBuffer.set(b, pixelOffset + 2240);\n              }\n\n              else if (type == 4) {\n                let mask = this.readBits(8);\n                for (let line = 0; line < 8; line++) {\n                  let lineIndex = 0;\n                  if (mask & (1 << line)) {\n                    lineIndex = TABLE_1[this.readBits(5)];\n                  } else {\n                    lineIndex = this.readBits(13);\n                  }\n                  let pixels = LINE_TABLE.subarray(lineIndex * 8, lineIndex * 8 + 8);\n                  pixelBuffer.set(pixels, pixelOffset + line * 320);\n                }\n              }\n\n              else if (type == 5) {\n                skip = this.readBits(5);\n                continue;\n              }\n\n              // type 6 doesnt exist\n\n              else if (type == 7) {\n                let pattern = this.readBits(2);\n                let useTable = this.readBits(1);\n                let lineIndexA = 0;\n                let lineIndexB = 0;\n\n                if (useTable) {\n                  lineIndexA = TABLE_1[this.readBits(5)];\n                  lineIndexB = TABLE_1[this.readBits(5)];\n                  pattern = (pattern + 1) % 4;\n                } else {\n                  lineIndexA = this.readBits(13);\n                  lineIndexB = this.readBits(13);\n                }\n\n                let a = LINE_TABLE.subarray(lineIndexA * 8, lineIndexA * 8 + 8);\n                let b = LINE_TABLE.subarray(lineIndexB * 8, lineIndexB * 8 + 8);\n\n                if (pattern == 0) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(b, pixelOffset + 320);\n                  pixelBuffer.set(a, pixelOffset + 640);\n                  pixelBuffer.set(b, pixelOffset + 960);\n                  pixelBuffer.set(a, pixelOffset + 1280);\n                  pixelBuffer.set(b, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(b, pixelOffset + 2240);\n                } else if (pattern == 1) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(a, pixelOffset + 320);\n                  pixelBuffer.set(b, pixelOffset + 640);\n                  pixelBuffer.set(a, pixelOffset + 960);\n                  pixelBuffer.set(a, pixelOffset + 1280);\n                  pixelBuffer.set(b, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(a, pixelOffset + 2240);\n                } else if (pattern == 2) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(b, pixelOffset + 320);\n                  pixelBuffer.set(a, pixelOffset + 640);\n                  pixelBuffer.set(a, pixelOffset + 960);\n                  pixelBuffer.set(b, pixelOffset + 1280);\n                  pixelBuffer.set(a, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(b, pixelOffset + 2240);\n                } else if (pattern == 3) {\n                  pixelBuffer.set(a, pixelOffset);\n                  pixelBuffer.set(b, pixelOffset + 320);\n                  pixelBuffer.set(b, pixelOffset + 640);\n                  pixelBuffer.set(a, pixelOffset + 960);\n                  pixelBuffer.set(b, pixelOffset + 1280);\n                  pixelBuffer.set(b, pixelOffset + 1600);\n                  pixelBuffer.set(a, pixelOffset + 1920);\n                  pixelBuffer.set(b, pixelOffset + 2240);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this._prevDecodedFrame = frameIndex;\n    // return this._layers;\n    return [\n      new Uint8Array(this._layers[0].buffer),\n      new Uint8Array(this._layers[1].buffer),\n      new Uint8Array(this._layers[2].buffer),\n    ];\n  }\n\n  getFramePalette(frameIndex) {\n    let flags = this.frameMeta[frameIndex].flags;\n    return [\n      this.palette[PALETTE_INDEX_MAP[flags & 0xF]], // paper color\n      this.palette[PALETTE_INDEX_MAP[(flags >> 8) & 0xF]], // layer A color 1\n      this.palette[PALETTE_INDEX_MAP[(flags >> 12) & 0xF]], // layer A color 2\n      this.palette[PALETTE_INDEX_MAP[(flags >> 16) & 0xF]], // layer B color 1\n      this.palette[PALETTE_INDEX_MAP[(flags >> 20) & 0xF]], // layer B color 2\n      this.palette[PALETTE_INDEX_MAP[(flags >> 24) & 0xF]], // layer C color 1\n      this.palette[PALETTE_INDEX_MAP[(flags >> 28) & 0xF]], // layer C color 2\n    ];\n  }\n\n  // retuns an uint8 array where each item is a pixel's palette index\n  getLayerPixels(frameIndex, layerIndex) {\n    if (this._prevDecodedFrame !== frameIndex) {\n      this.decodeFrame(frameIndex);\n    }\n    const layer = this._layers[layerIndex];\n    const image = new Uint8Array((320 * 240));\n    const paletteOffset = layerIndex * 2 + 1;\n    for (let index = 0; index < layer.length; index++) {\n      let pixel = layer[index];\n      if (pixel & 0xff00) {\n        image[index] = paletteOffset;\n      } else if (pixel & 0x00ff) {\n        image[index] = paletteOffset + 1;\n      }\n    }\n    return image;\n  }\n\n  // retuns an uint8 array where each item is a pixel's palette index\n  getFramePixels(frameIndex, useGlobalPalette = false) {\n    let paletteMap;\n    if (useGlobalPalette) {\n      const framePalette = this.getFramePalette(frameIndex);\n      paletteMap = framePalette.map(color => kwzParser.globalPalette.indexOf(color));\n    } else {\n      paletteMap = [0, 1, 2, 3, 4, 5, 6];\n    }\n    const image = new Uint8Array((320 * 240));\n    image.fill(paletteMap[0]);\n    const layerOrder = this.getLayerOrder(frameIndex);\n    layerOrder.forEach(layerIndex => {\n      const layer = this.getLayerPixels(frameIndex, layerIndex);\n      // merge layer into image result\n      for (let index = 0; index < layer.length; index++) {\n        let pixel = layer[index];\n        if (pixel !== 0) {\n          image[index] = paletteMap[pixel];\n        }\n      }\n    });\n    return image;\n  }\n  \n  decodeSoundFlags() {\n    return this.frameMeta.map(frame => {\n      let soundFlags = frame.soundFlags;\n      return [\n        soundFlags & 0x1,\n        (soundFlags >> 1) & 0x1,\n        (soundFlags >> 2) & 0x1,\n        (soundFlags >> 3) & 0x1,\n      ];\n    });\n  }\n\n  hasAudioTrack(trackIndex) {\n    let id = [\"bgm\", \"se1\", \"se2\", \"se3\", \"se4\"][trackIndex];\n    return this.soundMeta[id].length > 0\n  }\n\n  decodeAudio(track) {\n    let meta = this.soundMeta[track];\n    let output = new Int16Array(16364 * 60);\n    let outputOffset = 0;\n    let adpcm = new Uint8Array(this.buffer, meta.offset, meta.length);\n    // initial decoder state\n    var prevDiff = 0;\n    var prevStepIndex = 40;\n    var sample, diff, stepIndex;\n    // loop through each byte in the raw adpcm data\n    for (let index = 0; index < adpcm.length; index++) {\n      var byte = adpcm[index];\n      var bitPos = 0;\n      while (bitPos < 8) {\n        if (prevStepIndex < 18 || bitPos == 6) {\n          // isolate 2-bit sample\n          sample = (byte >> bitPos) & 0x3;\n          // get diff\n          diff = prevDiff + ADPCM_SAMPLE_TABLE_2[sample + 4 * prevStepIndex];\n          // get step index\n          stepIndex = prevStepIndex + ADPCM_INDEX_TABLE_2[sample];\n          bitPos += 2;\n        }\n        else {\n          // isolate 4-bit sample\n          sample = (byte >> bitPos) & 0xF;\n          // get diff\n          diff = prevDiff + ADPCM_SAMPLE_TABLE_4[sample + 16 * prevStepIndex];\n          // get step index\n          stepIndex = prevStepIndex + ADPCM_INDEX_TABLE_4[sample];\n          bitPos += 4;\n        }\n        // clamp step index and diff\n        stepIndex = Math.max(0, Math.min(stepIndex, 79));\n        diff = Math.max(-2048, Math.min(diff, 2048));\n        // add result to output buffer\n        output[outputOffset] = (diff * 16);\n        outputOffset += 1;\n        // set prev decoder state\n        prevStepIndex = stepIndex;\n        prevDiff = diff;\n      }\n\n    }\n    return output.slice(0, outputOffset);\n  }\n}\n\nkwzParser.width = 320;\nkwzParser.height = 240;\nkwzParser.globalPalette = [\n  PALETTE.BLACK,\n  PALETTE.WHITE,\n  PALETTE.RED,\n  PALETTE.YELLOW,\n  PALETTE.GREEN,\n  PALETTE.BLUE,\n  PALETTE.NONE,\n];","import dataStream from \"../utils/dataStream\";\n\nexport default class WavEncoder {\n  constructor(sampleRate, channels=1, bitsPerSample=16) {\n    this.sampleRate = sampleRate;\n    this.channels = channels;\n    this.bitsPerSample = bitsPerSample;\n    // Write WAV file header\n    // Reference: http://www.topherlee.com/software/pcm-tut-wavformat.html\n    let headerBuffer = new ArrayBuffer(44);\n    let header = new dataStream(headerBuffer);\n    // \"RIFF\" indent\n    header.writeUtf8(\"RIFF\");\n    // filesize (set later)\n    header.writeUint32(0);\n    // \"WAVE\" indent\n    header.writeUtf8(\"WAVE\");\n    // \"fmt \" section header\n    header.writeUtf8(\"fmt \");\n    // fmt section length\n    header.writeUint32(16);\n    // specify audio format is pcm (type 1)\n    header.writeUint16(1);\n    // number of audio channels\n    header.writeUint16(this.channels);\n    // audio sample rate\n    header.writeUint32(this.sampleRate);\n    // byterate = (sampleRate * bitsPerSample * channelCount) / 8\n    header.writeUint32((this.sampleRate * this.bitsPerSample * this.channels) / 8);\n    // blockalign = (bitsPerSample * channels) / 8\n    header.writeUint16((this.bitsPerSample * this.channels) / 8);\n    // bits per sample\n    header.writeUint16(this.bitsPerSample);\n    // \"data\" section header\n    header.writeUtf8(\"data\");\n    // data section length (set later)\n    header.writeUint32(0);\n    this.header = header;\n    this.pcmData = null;\n  }\n\n  writeFrames(pcmData) {\n    let header = this.header;\n    // fill in filesize\n    header.seek(4);\n    header.writeUint32(header.byteLength + pcmData.byteLength);\n    // fill in data section length\n    header.seek(40);\n    header.writeUint32(pcmData.byteLength);\n    this.pcmData = pcmData;\n  }\n\n  getBlob() {\n    return new Blob([this.header.buffer, this.pcmData.buffer], {type: \"audio/wav\"});\n  }\n}","import canvas from \"../webgl/canvas\";\nimport parser from \"../parser\";\nimport loader from \"../loader\";\nimport audioTrack from \"./audio\";\nimport webglCanvas from \"../webgl/canvas\";\n\n/** flipnote player API, based on HTMLMediaElement (https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement) */ \nexport default class flipnotePlayer {\n  /**\n  * Create new flipnote player\n  * @param {string | HTMLCanvasElement} el - HTML Canvas Element to use, or CSS selector for one\n  * @param {number} width - canvas width in pixels\n  * @param {number} height - canvas height in pixels\n  */\n  constructor(el, width, height) {\n    // if `el` is a string, use it to select an Element, else assume it's an element\n    el = (\"string\" == typeof el) ? document.querySelector(el) : el;\n    this.canvas = new canvas(el, width, height);\n    this._imgCanvas = new canvas(document.createElement(\"canvas\"), width, height, {\n      antialias: true,\n      preserveDrawingBuffer: true,\n    });\n    this._isOpen = false;\n    this._events = {};\n    this.loop = false;\n    this.currentFrame = 0;\n    this.paused = true;\n    this.customPalette = null;\n    this.audioTracks = [\n      new audioTrack(\"se1\"),\n      new audioTrack(\"se2\"),\n      new audioTrack(\"se3\"),\n      new audioTrack(\"se4\"),\n      new audioTrack(\"bgm\"),\n    ];\n    this.smoothRendering = false;\n  }\n\n  /**\n  * Get the index of the current frame \n  */\n  get currentFrame() {\n    return this._frame;\n  }\n\n  /**\n  * Set the current frame\n  */\n  set currentFrame(index) {\n    this.setFrame(index);\n  }\n\n  /**\n  * Get current playback time in seconds\n  */\n  get currentTime() {\n    return this._isOpen ? this.currentFrame * (1 / this.framerate) : null;\n  }\n\n  /**\n  * Set current playback time in seconds\n  */\n  set currentTime(value) {\n    if ((this._isOpen) && (value < this.duration) && (value > 0)) {\n      this.setFrame(Math.round(value / (1 / this.framerate)));\n    }\n  }\n\n  /**\n  * Get audio volume\n  */\n  get volume() {\n    return this.audioTracks[3].audio.volume;\n  }\n\n  /**\n  * Set audio volume\n  */\n  set volume(value) {\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].audio.volume = value;\n    }\n  }\n\n  /**\n  * Get audio mute\n  */\n  get muted() {\n    return this.audioTracks[3].audio.muted;\n  }\n\n  /**\n  * Set audio mute\n  */\n  set muted(value) {\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].audio.muted = value;\n    }\n  }\n\n  /**\n  * Get the duration of the Flipnote in seconds\n  */\n  get duration() {\n    return this._isOpen ? this.frameCount * (1 / this.framerate) : null;\n  }\n\n  /**\n  * Get the Flipnote framerate in frames-per-second\n  */\n  get framerate() {\n    return this.note.framerate;\n  }\n\n  /**\n  * Get the audio playback rate by comparing audio and frame speeds\n  * @access protected\n  */\n  get _audiorate() {\n    return (1 / this.note.bgmrate) / (1 / this.note.framerate);\n  }\n\n  /**\n  * Load a Flipnote into the player\n  * @param {ArrayBuffer} buffer - ppm data\n  * @access protected\n  */\n  _load(buffer) {\n    var note = new parser(buffer);\n    this.note = note;\n    this.meta = note.meta;\n    this.type = note.type;\n    this.frameCount = note.frameCount;\n    this.frameSpeed = note.frameSpeed;\n    this.fileLength = note.byteLength;\n    this.loop = note.meta.loop == 1;\n    this.paused = true;\n    this._isOpen = true;\n    this.audioTracks.forEach(track => {\n      track.sampleRate = note.sampleRate;\n    });\n    if (this.customPalette) {\n      this.setPalette(this.customPalette);\n    }\n    if (this.note.hasAudioTrack(1)) this.audioTracks[0].set(this.note.decodeAudio(\"se1\"), 1);\n    if (this.note.hasAudioTrack(2)) this.audioTracks[1].set(this.note.decodeAudio(\"se2\"), 1);\n    if (this.note.hasAudioTrack(3)) this.audioTracks[2].set(this.note.decodeAudio(\"se3\"), 1);\n    if (this.type === \"KWZ\" && this.note.hasAudioTrack(4)) this.audioTracks[3].set(this.note.decodeAudio(\"se4\"), 1);\n    if (this.note.hasAudioTrack(0)) this.audioTracks[4].set(this.note.decodeAudio(\"bgm\"), this._audiorate);\n    this._seFlags = this.note.decodeSoundFlags();\n    this._playbackLoop = null;\n    this._hasPlaybackStarted = false;\n    this.layerVisiblity = {\n      1: true,\n      2: true,\n      3: true\n    };\n    this.setMode(this.type);\n    this.setFrame(this.note.thumbFrameIndex);\n    this.emit(\"load\");\n  }\n\n  /**\n  * Load a Flipnote into the player\n  * @param {String} source - ppm url\n  */\n  open(source) {\n    if (this._isOpen) this.close();\n    return loader(source)\n      .then((buffer) => {\n        this._load(buffer);\n      })\n      .catch((err) => {\n        console.error(\"Error loading Flipnote:\", err);\n      });\n  }\n\n  /**\n  * Close the currently loaded Flipnote and clear the player canvas\n  */\n  close() {\n    this.pause();\n    this.note = null;\n    this._isOpen = false;\n    this.paused = true;\n    this.loop = null;\n    this.meta = null;\n    this.frameCount = null;\n    this.frameSpeed = null;\n    this._frame = 0;\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].unset();\n    }\n    this._seFlags = null;\n    this._hasPlaybackStarted = null;\n    this.canvas.clear();\n    this._imgCanvas.clear();\n  }\n\n  /**\n  * Destroy this player instance cleanly\n  */\n  destroy() {\n    this.close();\n    this.canvas.destroy();\n    this._imgCanvas.destroy();\n  }\n\n  /**\n  * Play the sound effects for a given frame\n  * @param {number} index - zero-based frame index\n  * @access protected\n  */\n  _playFrameSe(index) {\n    var flags = this._seFlags[index];\n    for (let i = 0; i < flags.length; i++) {\n      if (flags[i] && this.audioTracks[i].active) this.audioTracks[i].start();\n    }\n  }\n\n  /**\n  * Play the Flipnote BGM\n  * @access protected\n  */\n  _playBgm() {\n    this.audioTracks[4].start(this.currentTime);\n  }\n\n  /**\n  * Stop all audio tracks\n  * @access protected\n  */\n  _stopAudio() {\n    for (let i = 0; i < this.audioTracks.length; i++) {\n      this.audioTracks[i].stop();\n    }\n  }\n\n  /**\n  * Begin Flipnote playback\n  */\n  play() {\n    if ((!this._isOpen) || (!this.paused)) return null;\n    this.paused = false;\n    if ((!this._hasPlaybackStarted) || ((!this.loop) && (this.currentFrame == this.frameCount - 1))) this._frame = 0;\n    this._playBgm();\n    this._playbackLoop = setInterval(() => {\n      if (this.paused) clearInterval(this._playbackLoop);\n      // if the end of the flipnote has been reached\n      if (this.currentFrame >= this.frameCount -1) {\n        this._stopAudio();\n        if (this.loop) {\n          this.firstFrame();\n          this._playBgm(0);\n          this.emit(\"playback:loop\");\n        } else {\n          this.pause();\n          this.emit(\"playback:end\");\n        }\n      } else {\n        this._playFrameSe(this.currentFrame);\n        this.nextFrame();\n      }\n    }, 1000 / this.framerate);\n    this._hasPlaybackStarted = true;\n    this.emit(\"playback:start\");\n  }\n\n  /**\n  * Pause Flipnote playback\n  */\n  pause() {\n    if ((!this._isOpen) || (this.paused)) return null;\n    // break the playback loop\n    clearInterval(this._playbackLoop);\n    this.paused = true;\n    this._stopAudio();\n    this.emit(\"playback:stop\");\n  }\n\n  /**\n  * Get a specific frame as an image data URL\n  * @param {number|string} index - zero-based frame index, or pass \"thumb\" to get the thumbnail frame\n  * @param {string} type - image MIME type, default is image/png\n  * @param {number} encoderOptions - number between 0 and 1 indicating image quality if type is image/jpeg or image/webp\n  */\n  getFrameImage(index, width, height, type, encoderOptions) {\n    if (!this._isOpen) return null;\n    var canvas = this._imgCanvas;\n    if (canvas.width !== width || canvas.height !== height) canvas.resize(width, height);\n    // clamp frame index\n    index = (index == \"thumb\") ? (this.note.thumbFrameIndex) : (Math.max(0, Math.min(index, this.frameCount - 1)));\n    this.drawFrame(index, canvas);\n    return canvas.toImage(type, encoderOptions);\n  }\n\n  setPalette(palette) {\n    this.customPalette = palette;\n    this.note.palette = palette;\n    this.forceUpdate();\n  }\n\n  /**\n  * Jump to a specific frame\n  * @param {number} index - zero-based frame index\n  */\n  setFrame(index) {\n    if ((!this._isOpen) || (index === this.currentFrame)) return null;\n    // clamp frame index\n    index = Math.max(0, Math.min(Math.floor(index), this.frameCount - 1));\n    this._frame = index;\n    this._playbackFrameTime = 0;\n    this.drawFrame(index, this.canvas);\n    this.emit(\"frame:update\", this.currentFrame);\n  }\n\n  /**\n  * Draw a frame to a given canvas\n  * @param {number} index - zero-based frame index\n  * @param {webglCanvas} canvas - webgl frame canvas\n  */\n  drawFrame(frameIndex, canvas) {\n    let colors = this.note.getFramePalette(frameIndex);\n    let layerBuffers = this.note.decodeFrame(frameIndex);\n    canvas.setPaperColor(colors[0]);\n    canvas.clear();\n    if (this.note.type == \"PPM\") {\n      if (this.layerVisiblity[2]) canvas.drawLayer(layerBuffers[1], 256, 192, colors[2], [0,0,0,0]);\n      if (this.layerVisiblity[1]) canvas.drawLayer(layerBuffers[0], 256, 192, colors[1], [0,0,0,0]);\n    } else if (this.note.type == \"KWZ\") {\n      // loop through each layer\n      this.note.getLayerOrder(frameIndex).forEach(layerIndex => {\n        // only draw layer if it's visible\n        if (this.layerVisiblity[layerIndex + 1]) {\n          canvas.drawLayer(layerBuffers[layerIndex], 320, 240, colors[layerIndex * 2 + 1], colors[layerIndex * 2 + 2]);\n        }\n      });\n    }\n  }\n\n  /**\n  * Jump to the thumbnail frame\n  */\n  thumbnailFrame() {\n    this.currentFrame = this.note.thumbFrameIndex;\n  }\n\n  /**\n  * Jump to the next frame in the animation\n  */\n  nextFrame() {\n    if ((this.loop) && (this.currentFrame >= this.frameCount -1)) {\n      this.currentFrame = 0;\n    } else {\n      this.currentFrame += 1;\n    }\n  }\n\n  /**\n  * Jump to the previous frame in the animation\n  */\n  prevFrame() {\n    if ((this.loop) && (this.currentFrame <= 0)) {\n      this.currentFrame = this.frameCount - 1;\n    } else {\n      this.currentFrame -= 1;\n    }\n  }\n\n  /**\n  * Jump to the last frame in the animation\n  */\n  lastFrame() {\n    this.currentFrame = this.frameCount - 1;\n  }\n\n  /**\n  * Jump to the first frame in the animation\n  */\n  firstFrame() {\n    this.currentFrame = 0;\n  }\n\n  /**\n  * Resize player canvas\n  * @param {number} width - canvas width in pixels\n  * @param {number} height - canvas height in pixels\n  */\n  resize(width, height) {\n    this.canvas.resize(width, height);\n    this.forceUpdate();\n  }\n\n  /**\n  * Set layer visibility\n  * @param {number} index - layer number = 1, 2, 3\n  * @param {boolean} value\n  */\n  setLayerVisibility(index, value) {\n    this.layerVisiblity[index] = value;\n    this.forceUpdate();\n  }\n\n  /**\n  * Set smooth rendering\n  * @param {boolean} value\n  */\n  setSmoothRendering(value) {\n    var filter = value ? \"linear\" : \"nearest\";\n    this.canvas.setFilter(filter);\n    this.forceUpdate();\n    this.smoothRendering = value;\n  }\n\n  /**\n  * Set the mode depending on format\n  * @param {string} mode - \"KWZ\" | \"PPM\"\n  */\n  setMode(mode) {\n    this.canvas.setMode(mode);\n    this._imgCanvas.setMode(mode);\n  }\n\n  /**\n  * Force the player to redraw\n  */\n  forceUpdate() {\n    if (this._isOpen) {\n      this.drawFrame(this.currentFrame, this.canvas);\n    }\n  }\n\n  /**\n  * Register an event callback\n  * @param {string} eventType - event type\n  * @param {function} callback - event callback function\n  */\n  on(eventType, callback) {\n    var events = this._events;\n    (events[eventType] || (events[eventType] = [])).push(callback);\n  }\n\n  /**\n  * Remove an event callback\n  * @param {string} eventType - event type\n  * @param {function} callback - event callback function\n  */\n  off(eventType, callback) {\n    var callbackList = this._events[eventType];\n    if (callbackList) callbackList.splice(callbackList.indexOf(callback), 1);\n  }\n\n  /**\n  * Emit an event (used internally)\n  * @param {string} eventType - event type\n  * @param {...} args - arguments to be passed to event callback\n  */\n  emit(eventType, ...args) {\n    var callbackList = this._events[eventType] || [];\n    for (var i = 0; i < callbackList.length; i++) {\n      callbackList[i].apply(null, args); \n    }\n  }\n\n}","import vertexShader from \"./shader.vert\";\nimport fragmentShader from \"./shader.frag\";\n\n/** webgl canvas wrapper class */\nexport default class webglCanvas {\n  /**\n  * Create a rendering canvas\n  * @param {HTMLCanvasElement} el - The HTML canvas element\n  * @param {number} width - width of the canvas in pixels\n  * @param {number} height - height of the canvas in pixels\n  * @param {Object} params - optional params to pass to web gl context\n  */\n  constructor(el, width=640, height=480, params={antialias: false, alpha: false}) {\n    this.width = el.width = width;\n    this.height = el.height = height; \n    var gl = el.getContext(\"webgl\", params);\n    var program = gl.createProgram();\n    this.program = program;\n    this.el = el;\n    this.gl = gl;\n    this.refs = {\n      shaders:[],\n      textures:[],\n      buffers: []\n    };\n    // set up shaders\n    var vShader = this._createShader(gl.VERTEX_SHADER, vertexShader);\n    var fShader = this._createShader(gl.FRAGMENT_SHADER, fragmentShader);\n    gl.attachShader(program, vShader);\n    gl.attachShader(program, fShader);\n    // link program\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      let log = gl.getProgramInfoLog(program);\n      gl.deleteProgram(program);\n      throw new Error(log);\n    }\n    // activate the program\n    gl.useProgram(program);\n    // create quad that fills the screen, this will be our drawing surface\n    var vertBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1,  1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(0);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    this.refs.buffers.push(vertBuffer);\n    // create texture to use as the layer bitmap\n    gl.activeTexture(gl.TEXTURE0);\n    var tex = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    // get uniform locations\n    this.uniforms = {};\n    let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < uniformCount; i++) {\n      let name = gl.getActiveUniform(program, i).name;\n      this.uniforms[name] = gl.getUniformLocation(program, name);\n    }\n    gl.uniform1i(this.uniforms.u_bitmap, 0);\n    this.setFilter(\"linear\");\n    this.setMode(\"PPM\");\n    this.refs.textures.push(tex);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n  }\n  \n  /**\n  * Util to compile and attach a new shader\n  * @param {shader type} type - gl.VERTEX_SHADER | gl.FRAGMENT_SHADER\n  * @param {string} source - GLSL code for the shader\n  * @returns {shader} compiled webgl shader\n  * @access protected \n  */\n  _createShader(type, source) {\n    var gl = this.gl;\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    // test if shader compilation was successful\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      let log = gl.getShaderInfoLog(shader);\n      gl.deleteShader(shader);\n      throw new Error(log);\n    }\n    this.refs.shaders.push(shader);\n    return shader;\n  }\n\n  /**\n  * get the canvas content as an image\n  * @param {string} type - image MIME type, default is image/png\n  * @param {number} encoderOptions - number between 0 and 1 indicating image quality if type is image/jpeg or image/webp\n  * @returns {DataUrl}\n  */\n  toImage(type, encoderOptions) {\n    return this.el.toDataURL(type, encoderOptions);\n  }\n\n  /**\n  * Set the texture filter\n  * @param {string} filter - \"linear\" | \"nearest\"\n  */\n  setFilter(filter) {\n    var gl = this.gl;\n    filter = filter == \"linear\" ? gl.LINEAR : gl.NEAREST;\n    gl.uniform1i(this.uniforms.u_isSmooth, filter == \"linear\" ? 0 : 1);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n  }\n\n  /**\n  * Set the canvas mode depending on format\n  * @param {string} mode - \"KWZ\" | \"PPM\"\n  */\n  setMode(mode) {\n    const { gl } = this;\n    if (mode === \"PPM\") {\n      this.textureType = gl.ALPHA;\n    } else if (mode === \"KWZ\") {\n      this.textureType = gl.LUMINANCE_ALPHA;\n    }\n  }\n\n  /**\n  * Set a color\n  * @param {string} color - name of the color's uniform variable\n  * @param {array} value - r,g,b color, each channel's value should be between 0 and 255\n  */\n  setColor(color, value) {\n    this.gl.uniform4f(this.uniforms[color], value[0]/255, value[1]/255, value[2]/255, 1);\n  }\n\n  /**\n  * Set an palette individual color\n  * @param {array} value - r,g,b color, each channel's value should be between 0 and 255\n  */\n  setPaperColor(value) {\n    this.gl.clearColor(value[0] / 255, value[1] / 255, value[2] / 255, 1);\n  }\n\n  /**\n  * Draw a single frame layer\n  * @param {Uint16Array} buffer - layer pixels\n  * @param {number} width - layer width\n  * @param {number} height - layer height\n  * @param {array} color1 - r,g,b for layer color 1, each channel's value should be between 0 and 255\n  * @param {array} color2 - r,g,b for layer color 2, each channel's value should be between 0 and 255\n  * @param {number} depth - layer depth (kwz only, but currently unused)\n  */\n  drawLayer(buffer, width, height, color1, color2, depth) {\n    let gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0);\n    gl.texImage2D(gl.TEXTURE_2D, 0, this.textureType, width, height, 0, this.textureType, gl.UNSIGNED_BYTE, buffer);\n    // gl.uniform1f(gl.getUniformLocation(this.program, \"u_layerDepth\"), -depth/6);\n    this.setColor(\"u_color1\", color1);\n    this.setColor(\"u_color2\", color2);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  /**\n  * Resize canvas\n  * @param {number} width - width of the canvas in pixels\n  * @param {number} height - height of the canvas in pixels\n  */\n  resize(width=640, height=480) {\n    this.el.width = width;\n    this.el.height = height; \n    this.width = width;\n    this.height = height;\n    this.gl.viewport(0, 0, width, height);\n  }\n\n  /**\n  * Clear canvas\n  */\n  clear() {\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n  }\n\n  /** \n  * Destroy this canvas instance\n  */\n  destroy() {\n    // free resources\n    var refs = this.refs;\n    var gl = this.gl;\n    refs.shaders.forEach((shader) => {\n      gl.deleteShader(shader);\n    });\n    refs.shaders = [];\n    refs.textures.forEach((texture) => {\n      gl.deleteTexture(texture);\n    });\n    refs.textures = [];\n    refs.buffers.forEach((buffer) => {\n      gl.deleteBuffer(buffer);\n    });\n    refs.buffers = [];\n    gl.deleteProgram(this.program);\n    // shrink the canvas to reduce memory usage until it is garbage collected\n    gl.canvas.width = 1;\n    gl.canvas.height = 1;\n  }\n}","module.exports = \"#define GLSLIFY 1\\nattribute vec4 a_position;\\nvarying vec2 v_texcoord;\\nvoid main() {\\n  gl_Position = a_position;\\n  v_texcoord = a_position.xy * vec2(0.5, -0.5) + 0.5;\\n}\"","module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\nvarying vec2 v_texcoord;\\nuniform vec4 u_color1;\\nuniform vec4 u_color2;\\nuniform sampler2D u_bitmap;\\nuniform bool u_isSmooth;\\nvoid main() {\\n  float weightColor1 = texture2D(u_bitmap, v_texcoord).a;\\n  float weightColor2 = texture2D(u_bitmap, v_texcoord).r;\\n  float alpha = 1.0;\\n  if (u_isSmooth) {\\n    weightColor1 = smoothstep(0.0, .9, weightColor1);\\n    weightColor2 = smoothstep(0.0, .9, weightColor2);\\n    float alpha = weightColor1 + weightColor2;\\n  }\\n  gl_FragColor = vec4(u_color1.rgb, alpha) * weightColor1 + vec4(u_color2.rgb, alpha) * weightColor2;\\n}\\n\"","import urlLoader from \"./urlLoader\";\nimport fileLoader from \"./fileLoader\";\nimport arrayBufferLoader from \"./arrayBufferLoader\";\n\nconst loaders = [\n  urlLoader,\n  fileLoader,\n  arrayBufferLoader\n];\n\nexport default function load(source) {\n  return new Promise(function (resolve, reject) {\n    for (var i = 0; i < loaders.length; i++) {\n      var loader = loaders[i];\n      if (loader.matches(source)) {\n        loader.load(source, resolve, reject);\n        break;\n      }\n    }\n  });\n}","export default {\n\n  matches: function(source) {\n    return typeof source === \"string\";\n  },\n\n  load: function(source, resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", source, true);\n    xhr.responseType = \"arraybuffer\"; \n    xhr.onreadystatechange = function (e) {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(xhr.response);\n        } else {\n          reject({\n            type: \"httpError\",\n            status: xhr.status,\n            statusText: xhr.statusText\n          });\n        }\n      }\n    };\n    xhr.send(null);\n  }\n\n}","export default {\n\n  matches: function(source) {\n    return (source instanceof File);\n  },\n\n  load: function(source, resolve, reject) {\n    var reader = new FileReader();\n    reader.onload = (event) => {\n      resolve(event.target.result)\n    };\n    reader.onerror = (event) => {\n      reject({type: \"fileReadError\"});\n    };\n    reader.readAsArrayBuffer(source);\n  }\n\n}","export default {\n\n  matches: function(source) {\n    return (source instanceof ArrayBuffer);\n  },\n\n  load: function(source, resolve, reject) {\n    resolve(source);\n  }\n\n}","import wavEncoder from \"encoders/wav\";\n\nexport default class audioTrack {\n  /**\n  * Create a new audio player\n  */\n  constructor (id, type) {\n    this.id = id;\n    this.channelCount = 1;\n    this.bitsPerSample = 16;\n    this.sampleRate = 0;\n    this.playbackRate = 1;\n    this.audio = document.createElement(\"audio\");\n    this.audio.preload = true;\n    this.active = false;\n  }\n  \n  /**\n  * Set the audio track\n  * @param {Int16Array} pcmData - mono-channel 16-bit PCM audio\n  * @param {number} playbackRate - audio playback rate (1 = default)\n  */\n  set(pcmData, playbackRate) {\n    // the HTML5 audio element supports PCM audio if it's in a WAV wrapper\n    let wav = new wavEncoder(this.sampleRate * playbackRate, this.channelCount, this.bitsPerSample);\n    wav.writeFrames(pcmData);\n    this.url = window.URL.createObjectURL(wav.getBlob());\n    // use the blob url for the audio element\n    this.audio.src = this.url;\n    this.active = true;\n    this.playbackRate = playbackRate;\n    this.length = pcmData.length;\n  }\n\n  get duration() {\n    return this.audio.duration;\n  }\n\n  /**\n  * Clear the audio track\n  */\n  unset() {\n    if (this.active) {\n      window.URL.revokeObjectURL(this.url);\n      this.audio.src = \"\";\n      this.audio.load();\n      this.active = false;\n      this.playbackRate = 1;\n      this.length = null;\n    }\n  }\n\n  /**\n  * Start audio playback\n  * @param {number} offset - offset to begin playback at\n  */\n  start(offset) {\n    if (this.active) {\n      this.audio.currentTime = offset || 0;\n      this.audio.play();\n    }\n  }\n\n  /**\n  * Stop audio playback\n  */\n  stop() {\n    if (this.active) {\n      this.audio.pause();\n    }\n  }\n}","import dataStream from \"../utils/dataStream\";\n\n// round number to nearest multiple of n\nexport function roundToNearest(value, n) {\n  return Math.ceil(value / n) * n;\n}\n\n// simple bitmap class for rendering images\n// https://en.wikipedia.org/wiki/BMP_file_format\n\nexport default class BitmapEncoder {\n\n  constructor(width, height, bpp) {\n    this.width = width;\n    this.height = height;\n    this.vWidth = roundToNearest(width, 4);\n    this.vHeight = roundToNearest(height, 4);\n    this.bpp = bpp;\n    this.fileHeader = new dataStream(new ArrayBuffer(14));\n    this.fileHeader.writeUtf8(\"BM\"); // \"BM\" file magic\n    // using BITMAPV4HEADER dib header variant:\n    this.dibHeader = new dataStream(new ArrayBuffer(108))\n    this.dibHeader.writeUint32(108); // DIB header length\n    this.dibHeader.writeInt32(width); // width\n    this.dibHeader.writeInt32(height); // height\n    this.dibHeader.writeUint16(1); // color panes (always 1)\n    this.dibHeader.writeUint16(bpp); // bits per pixel\n    this.dibHeader.writeUint32(3); // compression method (3 = BI_BITFIELDS for rgba, 0 = no compression for 8 bit)\n    this.dibHeader.writeUint32((this.vWidth * this.height) / (bpp / 8)); // image data size, (width * height) / bits per pixel\n    this.dibHeader.writeUint32(3780); // x res, pixel per meter\n    this.dibHeader.writeUint32(3780); // y res, pixel per meter\n    this.dibHeader.writeUint32(0); // the number of colors in the color palette, set by setPalette() method\n    this.dibHeader.writeUint32(0); // the number of important colors used, or 0 when every color is important; generally ignored\n    this.dibHeader.writeUint32(0x00FF0000); // red channel bitmask\n    this.dibHeader.writeUint32(0x0000FF00); // green channel bitmask\n    this.dibHeader.writeUint32(0x000000FF); // blue channel bitmask\n    this.dibHeader.writeUint32(0xFF000000); // alpha channel bitmask\n    this.dibHeader.writeUtf8(\"Win \"); // LCS_WINDOWS_COLOR_SPACE \"Win \"\n    /// rest can be left as nulls\n  }\n\n  static fromFlipnoteFrame(flipnote, frameIndex) {\n    const format = flipnote.constructor;\n    const bmp = new BitmapEncoder(format.width, format.height, 8);\n    bmp.setPixels(flipnote.getFramePixels(frameIndex));\n    bmp.setPalette(flipnote.getFramePalette(frameIndex));\n    return bmp;\n  }\n\n  setFilelength(value) {\n    this.fileHeader.seek(2);\n    this.fileHeader.writeUint32(value);\n  }\n\n  setPixelOffset(value) {\n    this.fileHeader.seek(10);\n    this.fileHeader.writeUint32(value);\n  }\n\n  setCompression(value) {\n    this.dibHeader.seek(16);\n    this.dibHeader.writeUint32(value);\n  }\n\n  setPaletteCount(value) {\n    this.dibHeader.seek(32);\n    this.dibHeader.writeUint32(value);\n  }\n\n  setPalette(colors) {\n    let palette = new Uint32Array(Math.pow(2, this.bpp));\n    for (let index = 0; index < colors.length; index++) {\n      let color = colors[index % colors.length];\n      // bmp color order is ARGB\n      palette[index] = 0xFF000000 | (color[0] << 16) | (color[1] << 8) | (color[2]);\n    }\n    this.setPaletteCount(palette.length); // set number of colors in DIB header\n    this.setCompression(0); // set compression to 0 so we're not using 32 bit\n    this.palette = palette;\n  }\n\n  setPixels(pixelData) {\n    let pixels;\n    let pixelsLength = this.vWidth * this.height;\n    switch (this.bpp) {\n      case 8:\n        pixels = new Uint8Array(pixelsLength);\n        break;\n      case 32:\n        pixels = new Uint32Array(pixelsLength);\n        break;\n    }\n    // pixel rows are stored \"upside down\" in bmps\n    let w = this.width;\n    for (let y = 0; y < this.height; y++) {\n      let srcOffset = (w * this.height) - ((y + 1) * w);\n      let destOffset = (y * this.width);\n      pixels.set(pixelData.slice(srcOffset, srcOffset + this.width), destOffset);\n    }\n    this.pixels = pixels;\n  }\n\n  getBlob() {\n    let sections = [this.fileHeader.buffer, this.dibHeader.buffer];\n    let headerByteLength = this.fileHeader.byteLength + this.dibHeader.byteLength;\n    switch (this.bpp) {\n      case 1:\n      case 4:\n      case 8:\n        this.setFilelength(headerByteLength + this.pixels.byteLength + this.palette.byteLength);\n        this.setPixelOffset(headerByteLength + this.palette.byteLength);\n        sections = sections.concat([this.palette.buffer, this.pixels.buffer]);\n        break;\n      case 16:\n      case 32:\n        this.setFilelength(headerByteLength + this.pixels.byteLength);\n        this.setPixelOffset(headerByteLength);\n        sections = sections.concat([this.pixels.buffer]);\n        break;\n    }\n    return new Blob(sections, {type: \"image/bitmap\"})\n  }\n\n  getUrl() {\n    return window.URL.createObjectURL(this.getBlob());\n  }\n\n  getImage() {\n    var img = new Image(this.width, this.height);\n    img.src = this.getUrl();\n    return img;\n  }\n\n}\n","import { dataStream } from \"../flipnote\";\nimport { ByteArray } from \"../utils/byteArray\";\nimport { LZWEncoder } from \"./lzw\";\n\nexport default class GifEncoder {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.delay = 100;\n    // -1 = no repeat, 0 = forever. anything else is repeat count\n    this.repeat = -1;\n    this.colorDepth = 8;\n    this.palette = [];\n    this.data = new ByteArray();\n  }\n\n  static fromFlipnote(flipnote) {\n    const format = flipnote.constructor;\n    const gif = new GifEncoder(format.width, format.height);\n    gif.palette = format.globalPalette.flat();\n    gif.delay = 100 / flipnote.framerate\n    gif.repeat = flipnote.meta.loop ? -1 : 0;\n    gif.init();\n    for (let frameIndex = 0; frameIndex < flipnote.frameCount; frameIndex++) {\n      gif.writeFrame(flipnote.getFramePixels(frameIndex, true));\n    }\n    return gif;\n  }\n\n  static fromFlipnoteFrame(flipnote, frameIndex) {\n    const format = flipnote.constructor;\n    const gif = new GifEncoder(format.width, format.height);\n    gif.palette = format.globalPalette.flat();\n    gif.delay = 100 / flipnote.framerate\n    gif.repeat = flipnote.meta.loop ? -1 : 0;\n    gif.init();\n    gif.writeFrame(flipnote.getFramePixels(frameIndex, true));\n    return gif;\n  }\n\n  init() {\n    let paletteSize = this.palette.length / 3;\n    for (var p = 1; 1 << p < paletteSize; p += 1) {\n      continue;\n    }\n    this.colorDepth = p;\n    this.writeHeader();\n    this.writeColorTable();\n    this.writeNetscapeExt();\n  }\n\n  writeHeader() {\n    const header = new dataStream(new ArrayBuffer(13));\n    header.writeUtf8(\"GIF89a\");\n    // Logical Screen Descriptor\n    header.writeUint16(this.width);\n    header.writeUint16(this.height);\n    header.writeUint8(\n      0x80 | // 1 : global color table flag = 1 (gct used)\n      (this.colorDepth - 1) // 6-8 : gct size\n    );\n    header.writeUint8(0);\n    header.writeUint8(0);\n    this.data.writeBytes(new Uint8Array(header.buffer));\n  }\n\n  writeColorTable() {\n    const palette = new Uint8Array(3 * Math.pow(2, this.colorDepth));\n    palette.set(this.palette, 0);\n    this.data.writeBytes(palette);\n  }\n\n  writeGraphicsControlExt() {\n    const graphicsControlExt = new dataStream(new ArrayBuffer(8));\n    graphicsControlExt.writeBytes([\n      0x21, // extension introducer\n      0xF9, // graphic control label\n      4, // block size\n      0 // bitfield\n    ]);\n    graphicsControlExt.writeUint16(this.delay); // loop flag\n    graphicsControlExt.writeBytes([\n      0,\n      0\n    ]);\n    this.data.writeBytes(new Uint8Array(graphicsControlExt.buffer));\n  }\n\n  writeNetscapeExt() {\n    const netscapeExt = new dataStream(new ArrayBuffer(19));\n    netscapeExt.writeBytes([\n      0x21, // extension introducer\n      0xFF, // app extension label\n      11, // block size\n    ]);\n    netscapeExt.writeUtf8('NETSCAPE2.0');\n    netscapeExt.writeUint8(3); // subblock size\n    netscapeExt.writeUint8(1); // loop subblock id\n    netscapeExt.writeUint16(this.repeat); // loop flag\n    this.data.writeBytes(new Uint8Array(netscapeExt.buffer));\n  }\n\n  writeImageDesc() {\n    const desc = new dataStream(new ArrayBuffer(10));\n    desc.writeUint8(0x2C);\n    desc.writeUint16(0); // image left\n    desc.writeUint16(0); // image top\n    desc.writeUint16(this.width);\n    desc.writeUint16(this.height);\n    desc.writeUint8(0);\n    this.data.writeBytes(new Uint8Array(desc.buffer));\n  }\n\n  writePixels(pixels) {\n    const lzw = new LZWEncoder(this.width, this.height, pixels, this.colorDepth);\n    lzw.encode(this.data);\n  }\n\n  writeFrame(pixels) {\n    this.writeGraphicsControlExt();\n    this.writeImageDesc();\n    this.writePixels(pixels);\n  }\n\n  getBuffer() {\n    return this.data.getBuffer();\n  }\n\n  getBlob() {\n    return new Blob([this.getBuffer()], {type: \"image/gif\"})\n  }\n\n  getUrl() {\n    return window.URL.createObjectURL(this.getBlob());\n  }\n\n  getImage() {\n    var img = new Image(this.width, this.height);\n    img.src = this.getUrl();\n    return img;\n  }\n}","export class ByteArray {\n  constructor() {\n    this.page = -1;\n    this.pages = [];\n    this.newPage();\n  }\n  \n  newPage() {\n    this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);\n    this.cursor = 0;\n  }\n  \n  getData() {\n    const data = new Uint8Array((this.page) * ByteArray.pageSize + this.cursor);\n    this.pages.map((page, index) => {\n      if (index === this.page) {\n        data.set(page.slice(0, this.cursor), index * ByteArray.pageSize);\n      } else {\n        data.set(page, index * ByteArray.pageSize);\n      }\n    });\n    return data;\n  }\n\n  getBuffer() {\n    const data = this.getData();\n    return data.buffer;\n  }\n  \n  writeByte(val) {\n    if (this.cursor >= ByteArray.pageSize) this.newPage();\n    this.pages[this.page][this.cursor++] = val;\n  }\n\n  writeBytes(array, offset, length) {\n    for (var l = length || array.length, i = offset || 0; i < l; i++)\n      this.writeByte(array[i]);\n  }\n}\n\nByteArray.pageSize = 4096;","/*\n  LZWEncoder.js\n\n  Authors\n  Kevin Weiner (original Java version - kweiner@fmsware.com)\n  Thibault Imbert (AS3 version - bytearray.org)\n  Johan Nordberg (JS version - code@johan-nordberg.com)\n  James Daniel (ES6 version)\n\n  Acknowledgements\n  GIFCOMPR.C - GIF Image compression routines\n  Lempel-Ziv compression based on 'compress'. GIF modifications by\n  David Rowley (mgardi@watdcsu.waterloo.edu)\n  GIF Image compression - modified 'compress'\n  Based on: compress.c - File compression ala IEEE Computer, June 1984.\n  By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n  Jim McKie (decvax!mcvax!jim)\n  Steve Davies (decvax!vax135!petsd!peora!srd)\n  Ken Turkowski (decvax!decwrl!turtlevax!ken)\n  James A. Woods (decvax!ihnp4!ames!jaw)\n  Joe Orost (decvax!vax135!petsd!joe)\n*/\n\nconst EOF = -1;\nconst BITS = 12;\nconst HSIZE = 5003; // 80% occupancy\nconst masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,\n             0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,\n             0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\n\nexport class LZWEncoder {\n  constructor(width, height, pixels, colorDepth) {\n    this.width = width;\n    this.height = height;\n    this.pixels = pixels;\n    this.colorDepth = colorDepth;\n    this.initCodeSize = Math.max(2, this.colorDepth);\n    this.accum = new Uint8Array(256);\n    this.htab = new Int32Array(HSIZE);\n    this.codetab = new Int32Array(HSIZE);\n    this.cur_accum = 0;\n    this.cur_bits = 0;\n    this.a_count;\n    this.remaining;\n    this.curPixel = 0;\n    this.free_ent = 0; // first unused entry\n    this.maxcode;\n    // block compression parameters -- after all codes are used up,\n    // and compression rate changes, start over.\n    this.clear_flg = false;\n    // Algorithm: use open addressing double hashing (no chaining) on the\n    // prefix code / next character combination. We do a variant of Knuth's\n    // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n    // secondary probe. Here, the modular division first probe is gives way\n    // to a faster exclusive-or manipulation. Also do block compression with\n    // an adaptive reset, whereby the code table is cleared when the compression\n    // ratio decreases, but after the table fills. The variable-length output\n    // codes are re-sized at this point, and a special CLEAR code is generated\n    // for the decompressor. Late addition: construct the table according to\n    // file size for noticeable speed improvement on small files. Please direct\n    // questions about this implementation to ames!jaw.\n    this.g_init_bits = undefined;\n    this.ClearCode = undefined;\n    this.EOFCode = undefined;\n  }\n\n  // Add a character to the end of the current packet, and if it is 254\n  // characters, flush the packet to disk.\n  char_out(c, outs) {\n    this.accum[this.a_count++] = c;\n    if (this.a_count >= 254) this.flush_char(outs);\n  }\n\n  // Clear out the hash table\n  // table clear for block compress\n  cl_block(outs) {\n    cl_hash(HSIZE);\n    this.free_ent = this.ClearCode + 2;\n    this.clear_flg = true;\n    output(this.ClearCode, outs);\n  }\n\n  // Reset code table\n  cl_hash(hsize) {\n    for (var i = 0; i < hsize; ++i) this.htab[i] = -1;\n  }\n\n  compress(init_bits, outs) {\n    var fcode, c, i, ent, disp, hsize_reg, hshift;\n\n    // Set up the globals: this.g_init_bits - initial number of bits\n    this.g_init_bits = init_bits;\n\n    // Set up the necessary values\n    this.clear_flg = false;\n    this.n_bits = this.g_init_bits;\n    this.maxcode = this.get_maxcode(this.n_bits);\n\n    this.ClearCode = 1 << (init_bits - 1);\n    this.EOFCode = this.ClearCode + 1;\n    this.free_ent = this.ClearCode + 2;\n\n    this.a_count = 0; // clear packet\n\n    ent = this.nextPixel();\n\n    hshift = 0;\n    for (fcode = HSIZE; fcode < 65536; fcode *= 2) ++hshift;\n    hshift = 8 - hshift; // set hash code range bound\n    hsize_reg = HSIZE;\n    this.cl_hash(hsize_reg); // clear hash table\n\n    this.output(this.ClearCode, outs);\n\n    outer_loop: while ((c = this.nextPixel()) != EOF) {\n      fcode = (c << BITS) + ent;\n      i = (c << hshift) ^ ent; // xor hashing\n      if (this.htab[i] === fcode) {\n        ent = this.codetab[i];\n        continue;\n      } else if (this.htab[i] >= 0) { // non-empty slot\n        disp = hsize_reg - i; // secondary hash (after G. Knott)\n        if (i === 0) disp = 1;\n        do {\n          if ((i -= disp) < 0) i += hsize_reg;\n          if (this.htab[i] === fcode) {\n            ent = this.codetab[i];\n            continue outer_loop;\n          }\n        } while (this.htab[i] >= 0);\n      }\n      this.output(ent, outs);\n      ent = c;\n      if (this.free_ent < 1 << BITS) {\n        this.codetab[i] = this.free_ent++; // code -> hasthis.htable\n        this.htab[i] = fcode;\n      } else {\n        this.cl_block(outs);\n      }\n    }\n\n    // Put out the final code.\n    this.output(ent, outs);\n    this.output(this.EOFCode, outs);\n  }\n\n  encode(outs) {\n    outs.writeByte(this.initCodeSize); // write \"initial code size\" byte\n    this.remaining = this.width * this.height; // reset navigation variables\n    this.curPixel = 0;\n    this.compress(this.initCodeSize + 1, outs); // compress and write the pixel data\n    outs.writeByte(0); // write block terminator\n  }\n\n  // Flush the packet to disk, and reset the this.accumulator\n  flush_char(outs) {\n    if (this.a_count > 0) {\n      outs.writeByte(this.a_count);\n      outs.writeBytes(this.accum, 0, this.a_count);\n      this.a_count = 0;\n    }\n  }\n\n  get_maxcode(n_bits) {\n    return (1 << n_bits) - 1;\n  }\n\n  // Return the next pixel from the image\n  nextPixel() {\n    if (this.remaining === 0) return EOF;\n    --this.remaining;\n    var pix = this.pixels[this.curPixel++];\n    return pix & 0xff;\n  }\n\n  output(code, outs) {\n    this.cur_accum &= masks[this.cur_bits];\n\n    if (this.cur_bits > 0) this.cur_accum |= (code << this.cur_bits);\n    else this.cur_accum = code;\n\n    this.cur_bits += this.n_bits;\n\n    while (this.cur_bits >= 8) {\n      this.char_out((this.cur_accum & 0xff), outs);\n      this.cur_accum >>= 8;\n      this.cur_bits -= 8;\n    }\n\n    // If the next entry is going to be too big for the code size,\n    // then increase it, if possible.\n    if (this.free_ent > this.maxcode || this.clear_flg) {\n      if (this.clear_flg) {\n        this.maxcode = this.get_maxcode(this.n_bits = this.g_init_bits);\n        this.clear_flg = false;\n      } else {\n        ++this.n_bits;\n        if (this.n_bits == BITS) this.maxcode = 1 << BITS;\n        else this.maxcode = this.get_maxcode(this.n_bits);\n      }\n    }\n\n    if (code == this.EOFCode) {\n      // At EOF, write the rest of the buffer.\n      while (this.cur_bits > 0) {\n        this.char_out((this.cur_accum & 0xff), outs);\n        this.cur_accum >>= 8;\n        this.cur_bits -= 8;\n      }\n      this.flush_char(outs);\n    }\n  }\n}\n"],"sourceRoot":""}